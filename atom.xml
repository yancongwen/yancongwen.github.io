<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码字仓颉</title>
  <icon>https://www.gravatar.com/avatar/a5994a5939f4abc6acf7a902bab209a5</icon>
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.yancongwen.com/"/>
  <updated>2019-03-28T06:16:34.351Z</updated>
  <id>http://blog.yancongwen.com/</id>
  
  <author>
    <name>Yan Congwen</name>
    <email>ycwen1119@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>四大WebGIS地图引擎的对比选择</title>
    <link href="http://blog.yancongwen.com/2018/11/05/%E5%9B%9B%E5%A4%A7WebGIS%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E%E7%9A%84%E5%AF%B9%E6%AF%94%E9%80%89%E6%8B%A9/"/>
    <id>http://blog.yancongwen.com/2018/11/05/四大WebGIS地图引擎的对比选择/</id>
    <published>2018-11-05T04:42:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四大Webgis地图引擎的对比选择"><a href="#四大Webgis地图引擎的对比选择" class="headerlink" title="四大Webgis地图引擎的对比选择"></a>四大Webgis地图引擎的对比选择</h1><blockquote><p>选择的方式主要是根据业务需求，主要分为: 传统GIS业务(Leaflet)，三维业务(Cesium)，互联网展示型(MapboxGL)，老IE浏览器，老业务维护(OpenLayers)。</p></blockquote><h2 id="1、Leaflet"><a href="#1、Leaflet" class="headerlink" title="1、Leaflet"></a>1、Leaflet</h2><p>leaflet是常规的的最适合常规gis开发的地图，因此核心功能就是“传统GIS”功能.</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>主流投影坐标支持：几乎所有的主流投影坐标系都可以支持;</li><li>矢量表达：矢量专题图，矢量空间分析，矢量瓦片，矢量可视化等矢量表达;</li><li>全样式表达：可结合主流的互联网可视化技术，如D3,Echarts,Mapv，几乎主要的地图的可视化表达都可以实现;</li><li>功能全，操作友好：功能全，插件丰富，社区生态完善.出现bug几乎百度找到，对开发者友好;</li><li>跨平台：兼容大部分浏览器，跨平台强;</li><li>移动设备的支持：内部代码框架设计的时候考虑到移动设备的支持.针对移动设备天然支持;</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>没有使用webgl进行渲染，在可视化表达上差一点点;</li><li>没有使用硬件加速，在数据量上没有发挥硬件的最大效果;</li></ul><h2 id="2、Openlayers"><a href="#2、Openlayers" class="headerlink" title="2、Openlayers"></a>2、Openlayers</h2><p>openlayers强调的是老ie等浏览器的兼容性.</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>主流投影坐标系支持：几乎所有的主流投影坐标系都可以支持;</li><li>脚本一体化：功能全并且集成到官方脚本;</li><li>ogc协议：几乎是最遵循ogc协议的脚本了;</li><li>兼容性：兼容老的ie6789等疑难浏览器问题;</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>功能大而虚，很多功能有实现但是实际使用效果不理想;</li><li>可视化表达差劲;</li><li>内存释放与优化差;</li></ul><h2 id="3、Mapbox-GL"><a href="#3、Mapbox-GL" class="headerlink" title="3、Mapbox GL"></a>3、Mapbox GL</h2><p>Mapbox GL主要是构建世界上最漂亮的地图，因此核心功能就是一个“看”字.相关可视化库还有：<a href="http://kepler.gl/#/" target="_blank" rel="noopener">Kepler-GL</a>、<a href="https://github.com/ecomfe/echarts-gl" target="_blank" rel="noopener">Echarts-GL</a></p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>高效矢量瓦片：真正高效实用的矢量瓦片;</li><li>顶级可视化：真正顶级的可视化渲染，mapboxGL，echartGL，KeplerGl等;</li><li>高清矢量图形：真正顶级的高清矢量图形绘制SVG，Canvas;</li><li>顶级互联网技术加持：国内Baidu，国外Uber，Mapbox等顶级可视化巨头技术加持;</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>只支持web墨卡托投影(EPSG：3857);</li><li>三维表达局限于高程和基本高程无法支持浮空真三维模型，这就是mapbox的关于三维的设置项叫做<code>fill-extrusion</code>而不是<code>model</code>的原因;</li></ul><h2 id="4、Cesium"><a href="#4、Cesium" class="headerlink" title="4、Cesium"></a>4、Cesium</h2><p>Cesium强调的是BIM三维模型，倾斜摄影的表达，重点在于三维建模与时态模拟.<br><a href="https://github.com/vtxf/Cesium-Tutorials-Index" target="_blank" rel="noopener">Cesium相关资料汇总</a></p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>倾斜摄影：支持倾斜摄影，地形，海洋环境等三维场景展现;</li><li>BIM三维建模：支持BIM管网建模和3dx,gltf模型的展示;</li><li>时态表达：支持时态，时间播放，时间动画，时空聚类等时空展现;</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li>没有类似unity的特殊光晕效果，虽然使用了webgl但效果平平;</li><li>自成体系的模型与几何绘制策略，需要重新学习;</li><li>代码过重，并且主视图必须获取顶级div，影响工程代码结构;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;四大Webgis地图引擎的对比选择&quot;&gt;&lt;a href=&quot;#四大Webgis地图引擎的对比选择&quot; class=&quot;headerlink&quot; title=&quot;四大Webgis地图引擎的对比选择&quot;&gt;&lt;/a&gt;四大Webgis地图引擎的对比选择&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="gis" scheme="http://blog.yancongwen.com/tags/gis/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 网络请求参数中带有特殊符号相关问题</title>
    <link href="http://blog.yancongwen.com/2018/10/21/http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%AD%E5%B8%A6%E6%9C%89%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.yancongwen.com/2018/10/21/http网络请求参数中带有特殊符号相关问题/</id>
    <published>2018-10-21T05:21:33.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-网络请求参数中带有特殊符号相关问题"><a href="#HTTP-网络请求参数中带有特殊符号相关问题" class="headerlink" title="HTTP 网络请求参数中带有特殊符号相关问题"></a>HTTP 网络请求参数中带有特殊符号相关问题</h1><h2 id="1、GET-请求参数中带有空格"><a href="#1、GET-请求参数中带有空格" class="headerlink" title="1、GET 请求参数中带有空格"></a>1、GET 请求参数中带有空格</h2><p>请求参数中带有空格会被处理为<code>+</code>号。这是<code>HTML4</code>标准中定义的，请看这里<a href="https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1" target="_blank" rel="noopener">Form content types</a>。<br>在<code>HTTP</code>请求头中，首部字段<code>Content-type</code>用于指示资源的MIME类型，规定了提交表单元素时对数据的处理方式。下面是几个常见的值：<br>1.text/html<br>2.text/plain<br>3.text/css<br>4.text/javascript<br>5.application/x-www-form-urlencoded<br>6.multipart/form-data<br>7.application/json<br>8.application/xml<br>…<br>其中<code>application/x-www-form-urlencoded</code>是默认值，使用该值时，提交表单时内容会按照如下规则编码：空格转换为<code>+</code>号；非法字符转换为类似于<code>%E0</code>的两位16进制表示的ASCII码；换行符被转换为<code>CR LF</code>；数据项名称和数据值以<code>=</code>号分割，数据项与数据项之间以<code>&amp;</code>分割；…….<br>按照以上规则，在<code>GET</code>请求中，我们的请求参数会按照以上编码规则进行编码，然后拼接到请求<code>URL</code>后面。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123; </span><br><span class="line">  type： <span class="string">'GET'</span>,</span><br><span class="line">  url: <span class="string">"http://ip:port/count"</span>,</span><br><span class="line">  data: &#123; <span class="attr">app</span>: <span class="string">'互联网 举证'</span> &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当我们发起以上请求时，请求参数会进行转码后拼接在 <code>url</code> 后面，空格被转换为了<code>+</code>号，真正的请求 <code>URI</code> 为 <code>http://ip:port/count?app=app=%E4%BA%92%E8%81%94%E7%BD%91+%E4%B8%BE%E8%AF%81</code><br><img src="https://img.yancongwen.cn/18-10-20/32458749.jpg" alt><br>当我们直接在浏览器地址栏中输入请求地址，如下图（<code>%20</code>就是输入的空格），浏览器就会去请求你输入的地址，而不会再将特殊字符转码。但是会将中文转码。（其实相当于执行了JS中的<code>encodeURI</code>）<br><img src="https://img.yancongwen.cn/18-10-20/2972838.jpg" alt></p><h2 id="2、GET-请求参数中带有-号"><a href="#2、GET-请求参数中带有-号" class="headerlink" title="2、GET 请求参数中带有 + 号"></a>2、GET 请求参数中带有 + 号</h2><p><code>+</code> 号和汉字一样，会被转码，转码后为 <code>%2B</code>。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123; </span><br><span class="line">  type： <span class="string">'GET'</span>,</span><br><span class="line">  url: <span class="string">"http://ip:port/count"</span>,</span><br><span class="line">  data: &#123; <span class="attr">app</span>: <span class="string">'互联网+举证'</span> &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当我们发起以上请求时，请求参数会进行转码后拼接在 <code>url</code> 后面，<code>+</code>号被转为<code>%2B</code>,真正的请求 <code>URI</code> 为 <code>http://ip:port/count?app=%E4%BA%92%E8%81%94%E7%BD%91%2B%E4%B8%BE%E8%AF%81</code><br><img src="https://img.yancongwen.cn/18-10-20/89868941.jpg" alt><br>直接在浏览器地址栏中输入请求地址，参数中带有<code>+</code>号，真实请求中就会保留<code>+</code>号。<br><img src="https://img.yancongwen.cn/18-10-20/94235014.jpg" alt></p><p>请细细品味这这几个示例的区别。</p><h2 id="3、JavaScript中的-URI-编码解码方法"><a href="#3、JavaScript中的-URI-编码解码方法" class="headerlink" title="3、JavaScript中的 URI 编码解码方法"></a>3、JavaScript中的 URI 编码解码方法</h2><ul><li><p>encodeURI<br>  该方法用于将一个<strong>完整</strong>的URI编码，该方法不会对那些保留的并且在URI中有特殊意思的字符进行编码；</p></li><li><p>decodeURI<br>  该方法解码一个由<code>encodeURI</code>先前创建的统一资源标识符（URI）；</p></li><li><p>encodeURIComponent<br>  对统一资源标识符（URI）的<strong>组成部分</strong>进行编码的方法。转义除了字母、数字、<code>(</code>、<code>)</code>、<code>.</code>、<code>!</code>、<code>~</code>、<code>*</code>、<code>&#39;</code>、<code>-</code>和<code>_</code>之外的所有字符。<br>  <strong>对于 <code>application/x-www-form-urlencoded</code> (POST) 这种数据方式，空格需要被替换成 ‘+’，所以通常使用 <code>encodeURIComponent</code> 的时候还会把 “%20” 替换为 “+”。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" target="_blank" rel="noopener">参考</a></strong></p></li><li><p>decodeURIComponent<br>  用于解码由<code>encodeURIComponent</code>或者其它类似方法编码的部分统一资源标识符（URI）。</p></li></ul><p><img src="https://img.yancongwen.cn/18-10-20/22263377.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-网络请求参数中带有特殊符号相关问题&quot;&gt;&lt;a href=&quot;#HTTP-网络请求参数中带有特殊符号相关问题&quot; class=&quot;headerlink&quot; title=&quot;HTTP 网络请求参数中带有特殊符号相关问题&quot;&gt;&lt;/a&gt;HTTP 网络请求参数中带有特殊符号相关
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解 jQuery</title>
    <link href="http://blog.yancongwen.com/2018/10/21/jquery/"/>
    <id>http://blog.yancongwen.com/2018/10/21/jquery/</id>
    <published>2018-10-21T05:20:10.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解-jQuery"><a href="#理解-jQuery" class="headerlink" title="理解 jQuery"></a>理解 jQuery</h1><h2 id="1、还有必要学习-jQuery-吗"><a href="#1、还有必要学习-jQuery-吗" class="headerlink" title="1、还有必要学习 jQuery 吗"></a>1、还有必要学习 jQuery 吗</h2><p>首先必须肯定的回答：有必要。<br>虽然目前 MVVM 框架很流行，但 jQuery 依然占据一定地位。某些特定场景的项目 jQuery 依然是最好的选择，jQuery帮助我们解决了太多的兼容性问题，而且对于有一定JS基础的人来说学习 jQuery 的成本很低，没必要去掌握全部API，只要会查文档就可以。虽然新项目中不一定会使用 jQuery ，但是学习 jQuery ，尤其是去阅读 jQuery 源码，理解其设计思想、设计模式，你将会颇有收获。</p><h2 id="2、jQuery-DOM-操作设计思想"><a href="#2、jQuery-DOM-操作设计思想" class="headerlink" title="2、jQuery DOM 操作设计思想"></a>2、jQuery DOM 操作设计思想</h2><p>jQuery 的基本设计思想和主要用法，就是”选择某个网页元素，然后对其进行某种操作”。使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery()（简写为$），得到被选中的元素，选中的元素可能是一个，也可能是多个。第二步就是对这些元素进行一系列操作，例如添加class、移除class、取值和赋值、移动等。 jQuery的一大特点就是支持链式操作，即类似于这样<code>$(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;Hello&#39;);</code>,将一系列操作连接在一起。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。</p><h2 id="3、自己实现一个简单的-jQuery"><a href="#3、自己实现一个简单的-jQuery" class="headerlink" title="3、自己实现一个简单的 jQuery"></a>3、自己实现一个简单的 jQuery</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector);</span><br><span class="line">    nodeList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">      nodes[index] = item;</span><br><span class="line">    &#125;);</span><br><span class="line">    nodes.length = nodeList.length;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeOrSelector <span class="keyword">instanceof</span> Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      <span class="string">'1'</span>: nodeOrSelector,</span><br><span class="line">      lenght: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classNames</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nodes.length; i++) &#123;</span><br><span class="line">      classNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        nodes[i].classList.add(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  nodes.setText = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nodes.length; i++) &#123;</span><br><span class="line">      nodeList[i].innerHTML  = text;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// alias</span></span><br><span class="line"><span class="built_in">window</span>.$ = jQuery</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">$(<span class="string">'ul&gt;li'</span>).addClass([<span class="string">'red'</span>,<span class="string">'blue'</span>]);</span><br><span class="line">$(<span class="string">'ul&gt;li'</span>).setText(<span class="string">'Hello jQuery'</span>);</span><br></pre></td></tr></table></figure><p>以上是本人实现的一个简单的jQuery对象。该对象接收一个参数，可以是一个已经获取到的DOM对象，也可以是一个选择器字符串。jQuery方法返回的是一个自定义的节点对象，该对象上定义了addClass、setText等一系列操作方法。</p><h2 id="4、jQuery获取DOM和JS选择器获取的DOM的区别与联系"><a href="#4、jQuery获取DOM和JS选择器获取的DOM的区别与联系" class="headerlink" title="4、jQuery获取DOM和JS选择器获取的DOM的区别与联系"></a>4、jQuery获取DOM和JS选择器获取的DOM的区别与联系</h2><p>例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'x'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'x'</span>)</span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'#x'</span>)</span><br></pre></td></tr></table></figure><ul><li>div 是由原生API获取的元素节点对象，<br>  <code>div.__proto__ === HTMLDivElement.prototype</code><br>  <code>div.__proto__.__proto__ === HTMLElement .prototype</code></li><li>$div 是jQuery对象实例，它包含了从jQuery继承过来的很多方法和属性<br>  <code>$div.__proto__ === jQuery.prototype</code><br>  <code>$div.__proto__ .__proto__ === Object.prototype</code></li><li>div 变成 $div:<br>  <code>$(div)</code></li><li>$div 变成 div:<br>  <code>$div[0] === div</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理解-jQuery&quot;&gt;&lt;a href=&quot;#理解-jQuery&quot; class=&quot;headerlink&quot; title=&quot;理解 jQuery&quot;&gt;&lt;/a&gt;理解 jQuery&lt;/h1&gt;&lt;h2 id=&quot;1、还有必要学习-jQuery-吗&quot;&gt;&lt;a href=&quot;#1、还有必要学习
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git提交信息规范化</title>
    <link href="http://blog.yancongwen.com/2018/10/12/git%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    <id>http://blog.yancongwen.com/2018/10/12/git提交信息规范化/</id>
    <published>2018-10-12T06:37:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-commit-信息规范化"><a href="#git-commit-信息规范化" class="headerlink" title="git commit 信息规范化"></a>git commit 信息规范化</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>&emsp;&emsp;Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面代码的<code>-m</code>参数，就是用来指定 <code>commit mesage</code> 的。如果一行不够，可以只执行<code>git commit</code>，就会跳出文本编辑器，让你写多行。<br>&emsp;&emsp;git 并没有规定你提交信息的内容和格式，但是，一个好的项目，一定要有一个自己的统一的提交格式，以便于后期回顾代码。目前，社区有多种 Commit message 的<a href="https://github.com/ajoslin/conventional-changelog/blob/master/conventions" target="_blank" rel="noopener">写法规范</a>。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener">Angular 规范</a>，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p><h2 id="2、规范"><a href="#2、规范" class="headerlink" title="2、规范"></a>2、规范</h2><p>&emsp;&emsp;每次提交，Commit message 都包括三个部分：Header（必需），Body（可选） 和 Footer（可选）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure></p><ul><li><p>Header 部分只有一行，包括三个字段：</p><ul><li><code>type（必需）</code> 用于说明 commit 的类别，只允许使用下面7个标识。<ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动    </li></ul></li><li><code>scope（可选）</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。    </li><li><code>subject（必需）</code>是 commit 目的的简短描述，不超过50个字符。</li></ul></li><li><p>Body 部分是对本次 commit 的详细描述</p></li><li>Footer 部分只用于两种情况（详细请看阮一峰博客）<ul><li>不兼容变动</li><li>关闭 Issue </li></ul></li></ul><h2 id="3、设置-git-commit-模板"><a href="#3、设置-git-commit-模板" class="headerlink" title="3、设置 git commit 模板"></a>3、设置 git commit 模板</h2><p>&emsp;&emsp;如果你只是个人的项目, 或者想尝试一下这样的规范格式, 那么你可以为 git 设置 commit template, 每次 git commit 的时候在 vim 中带出, 以时刻提醒自己提交规范。<br>修改 ~/.gitconfig, 添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[commit]</span><br><span class="line">template = ~/.gitmessage</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;新建 ~/.gitmessage 内容可以如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># head: (): </span><br><span class="line"># - type: feat, fix, docs, style, refactor, test, chore</span><br><span class="line"># - scope: can be empty (eg. if the change is a global or difficult to assign to a single component)</span><br><span class="line"># - subject: start with verb (such as &apos;change&apos;), 50-character line</span><br><span class="line">#</span><br><span class="line"># body: 72-character wrapped. This should answer:</span><br><span class="line"># * Why was this change necessary?</span><br><span class="line"># * How does it address the problem?</span><br><span class="line"># * Are there any side effects?</span><br><span class="line">#</span><br><span class="line"># footer: </span><br><span class="line"># - Include a link to the ticket, if any.</span><br><span class="line"># - BREAKING CHANGE</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;按照以上方式设置以后，每次执行 <code>git commit</code> 命令提交时进入 vim 编辑器，就会出现提交规范提示信息。</p><h2 id="4、工具：Commitizen"><a href="#4、工具：Commitizen" class="headerlink" title="4、工具：Commitizen"></a>4、工具：Commitizen</h2><p>&emsp;&emsp;<code>Commitizen</code> 是一个帮助我们撰写合格 Commit message 的工具。它提供一个交互式的命令行工具 <code>commitizen/cz-cli</code> 帮助我们生成符合规范的 commit message。除此之外, 我们还需要为 commitizen 指定一个 Adapter 比如: <code>cz-conventional-changelog</code> (一个符合 Angular团队规范的 preset). 使得 commitizen 按照我们指定的规范帮助我们生成 commit message.</p><h3 id="4-1-全局安装和使用"><a href="#4-1-全局安装和使用" class="headerlink" title="4.1 全局安装和使用"></a>4.1 全局安装和使用</h3><ul><li>全局安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &apos;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&apos; &gt; ~/.czrc</span><br></pre></td></tr></table></figure></li></ul><p>全局模式下, 需要 ~/.czrc 配置文件, 为 commitizen 指定 Adapter</p><ul><li>使用<br>&emsp;&emsp;如果全局安装过 commitizen, 那么在对应的项目中执行 <code>git cz</code> 或者 <code>npm run commit</code> 来替代 <code>git commit</code> 就可以了。执行命令后会进入一个交互式的命令环境，按照提示填写内容就可以了。如图：<br><img src="https://img.yancongwen.cn/18-10-9/88873392.jpg" alt><blockquote><p>提示：如果你是在Windows中使用 Git Bash 执行命令，交互提示符并不工作。你必须通过 <code>winpty git cz</code> 启动这个命令。</p></blockquote></li></ul><h3 id="4-2-项目级安装和使用"><a href="#4-2-项目级安装和使用" class="headerlink" title="4.2 项目级安装和使用"></a>4.2 项目级安装和使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure><p>package.json中配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;script&quot;:&#123;</span><br><span class="line">    &quot;commit&quot;:&quot;git-cz&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;config&quot;:&#123;</span><br><span class="line">    &quot;commitizen&quot;:&#123;</span><br><span class="line">        &quot;path&quot;:&quot;node_modules/cz-conventional-changelog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-自定义-Adapter"><a href="#4-3-自定义-Adapter" class="headerlink" title="4.3 自定义 Adapter"></a>4.3 自定义 Adapter</h3><p>也许 Angular 的那套规范我们不习惯, 那么可以通过指定 Adapter cz-customizable 指定一套符合自己团队的规范。我本人采用的就是使用最广泛的 Angular 规范，关于自定义规范，这里不再重复描述，具体请看<a href="http://chuansong.me/n/2233522251134" target="_blank" rel="noopener">这里</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰：Commit message 和 Change log 编写指南</a></li><li><a href="http://chuansong.me/n/2233522251134" target="_blank" rel="noopener">优雅的提交你的 Git Commit Message</a></li><li><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">https://github.com/commitizen/cz-cli</a></li><li><a href="https://segmentfault.com/a/1190000009048911" target="_blank" rel="noopener">git commit 规范指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-commit-信息规范化&quot;&gt;&lt;a href=&quot;#git-commit-信息规范化&quot; class=&quot;headerlink&quot; title=&quot;git commit 信息规范化&quot;&gt;&lt;/a&gt;git commit 信息规范化&lt;/h1&gt;&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="git" scheme="http://blog.yancongwen.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://blog.yancongwen.com/2018/09/18/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://blog.yancongwen.com/2018/09/18/原型与原型链/</id>
    <published>2018-09-18T08:09:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><blockquote><p>大多数编程语言是基于类的语言，而 JS 是一种基于原型继承的语言。</p></blockquote><h2 id="1、为什么会有原型和原型链？"><a href="#1、为什么会有原型和原型链？" class="headerlink" title="1、为什么会有原型和原型链？"></a>1、为什么会有原型和原型链？</h2><p>&emsp;&emsp;首先，先来看一下为什么会有原型和原型链，原型和原型链能带来什么好处。在面向对象编程中，创建对象的的方式有很多种，最最简单的就是工厂模式和构造函数模式，然而，这些方式创建的对象，不能共享属性和方法，每一个对象会重复创建相同的属性和方法，造成内存资源的浪费。最简单的，每个变量都会有一个 <code>toString</code> 方法，那么是每个变量都有一个自己的方法吗，显然不是的。原型的作用就是帮助我们存放公用的属性和方法。</p><h2 id="2、理解原型对象"><a href="#2、理解原型对象" class="headerlink" title="2、理解原型对象"></a>2、理解原型对象</h2><p>&emsp;&emsp;我们创建的每一个<strong>函数</strong>都有一个<code>prototype</code>属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，这个对象就是该函数的原型对象。原型对象自动获得一个<code>constructor</code>属性，这个属性又指向了函数本身。</p><h2 id="3、理解原型链"><a href="#3、理解原型链" class="headerlink" title="3、理解原型链"></a>3、理解原型链</h2><p>&emsp;&emsp;简单来讲，构造函数、原型、实例有如下关系：每一个构造函数都有一个原型对象<code>prototypr</code>，原型对象都包含一个指向构造函数的指针<code>constructor</code>，而实例都包含一个指向原型对象的内部指针<code>__proto__</code>。<br>&emsp;&emsp;基于以上关系，我们让一个构造函数的原型等于另一个类型的实例，此时，该原型对象就包含了一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。加入另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是原型链的基本概念。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><ul><li>1、 <code>prototype</code>是函数的原型对象，它是一个对象，这个对象又包含了一个<code>constructor</code>属性指向了该函数（<code>prototype</code>是函数的属性，而且我们一般讨论的是构造函数）；</li><li>2、 对象的<code>__proto__</code>指向它构造函数的<code>prototype</code>（<code>__proto__</code>是实例的属性）；</li><li>3、 所有的构造函数的原型链最后都会指向<code>Object</code>构造函数的原型，即可以理解<code>Object</code>构造函数的原型是所有原型链的最底层，即<code>Object.prototype.__proto__===null</code>；</li><li>4、 要寻找一个函数的<code>prototype</code>，就先看它是从谁继承来的；</li><li>5、 要寻找一个对象的<code>__proto__</code>，就先看它是谁的实例，找它的构造函数；</li></ul><h2 id="5、举例"><a href="#5、举例" class="headerlink" title="5、举例"></a>5、举例</h2><p>记住上一小节中的几句话，我们再来看下面的题目，就比较简单了。<strong>以下等式恒成立</strong>：</p><ul><li>第一组: (几个原生对象的原型关系)  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// 将Object视为Function的实例</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// 将Object视为构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// 将Function视为Function的实例</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//将Function视为构造函数，它的原型是Object的一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// 将Array视为Function的实例</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//将Array视为构造函数，它的原型是Object的一个实例</span></span><br><span class="line"><span class="comment">//类推 Boolean、 String、 Number......</span></span><br></pre></td></tr></table></figure><ul><li>第二组：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// obj是Object的实例</span></span><br><span class="line">obj.prototype === <span class="literal">undefined</span> <span class="comment">// obj不是函数，所以没有原型对象属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">arr.__proto__ === <span class="built_in">Array</span>.prototype <span class="comment">// arr是Array的实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">fn.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// 将fn视为Function的实例</span></span><br><span class="line">fn.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// 将fn视为函数，它的原型是Object的一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Test()</span><br><span class="line">Test.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// 将Test视为构造函数，它的原型是Object的一个实例</span></span><br><span class="line">test.__proto__ === Test.prototype <span class="comment">// test是Test的实例</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/7119f0ab67c0" target="_blank" rel="noopener">三句话给你解释清楚原型和原型链</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型与原型链&quot;&gt;&lt;a href=&quot;#原型与原型链&quot; class=&quot;headerlink&quot; title=&quot;原型与原型链&quot;&gt;&lt;/a&gt;原型与原型链&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;大多数编程语言是基于类的语言，而 JS 是一种基于原型继承的语言。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://blog.yancongwen.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS数据类型转换</title>
    <link href="http://blog.yancongwen.com/2018/09/18/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://blog.yancongwen.com/2018/09/18/JS数据类型转换/</id>
    <published>2018-09-18T08:07:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-数据类型转换"><a href="#JS-数据类型转换" class="headerlink" title="JS 数据类型转换"></a>JS 数据类型转换</h1><h2 id="任意类型转字符串"><a href="#任意类型转字符串" class="headerlink" title="任意类型转字符串"></a>任意类型转字符串</h2><ul><li>String(x)<br><img src="https://img.yancongwen.cn/18-9-20/9436618.jpg" alt></li><li>x.toString()<br><img src="https://img.yancongwen.cn/18-9-20/40339551.jpg" alt></li><li>x + ‘’<br><img src="https://img.yancongwen.cn/18-9-20/5923289.jpg" alt></li></ul><h2 id="任意类型转布尔"><a href="#任意类型转布尔" class="headerlink" title="任意类型转布尔"></a>任意类型转布尔</h2><ul><li>六个 <strong>falsy</strong> 值：<code>false</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>、<code>&#39;&#39;</code>(其实还有一个<code>document.all</code>)，除了以上六个值被转为<code>false</code>外，其他值都转为true； </li><li>所有的对象都被转换为 <code>true</code>（数组、函数、空数组、空对象）  </li><li>Boolean(x)<br><img src="https://img.yancongwen.cn/18-9-18/2569689.jpg" alt></li><li>!!x<br><img src="https://img.yancongwen.cn/18-9-18/79806060.jpg" alt></li></ul><h2 id="任意类型转数字"><a href="#任意类型转数字" class="headerlink" title="任意类型转数字"></a>任意类型转数字</h2><ul><li>Number(x)</li><li>parseInt(x, 10)</li><li>parseFloat(x) </li><li>x - 0</li><li>+x</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS-数据类型转换&quot;&gt;&lt;a href=&quot;#JS-数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;JS 数据类型转换&quot;&gt;&lt;/a&gt;JS 数据类型转换&lt;/h1&gt;&lt;h2 id=&quot;任意类型转字符串&quot;&gt;&lt;a href=&quot;#任意类型转字符串&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://blog.yancongwen.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS里的数据类型</title>
    <link href="http://blog.yancongwen.com/2018/09/17/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.yancongwen.com/2018/09/17/JS里的数据类型/</id>
    <published>2018-09-17T13:27:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS中的数据类型"><a href="#JS中的数据类型" class="headerlink" title="JS中的数据类型"></a>JS中的数据类型</h1><p>七种：<code>number</code>、<code>string</code>、 <code>boolean</code>、 <code>undefined</code>、 <code>null</code>、 <code>object</code>、 <code>symbol</code><br>没有 array 噢</p><h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><ul><li>整数和小数：<code>1</code>、 <code>1.1</code>、 <code>.1</code></li><li>科学记数法：<code>1.23e2</code></li><li>二进制：<code>0b11</code></li><li>八进制：<code>011</code>（后来 ES5 添加了 0o11 语法）</li><li>十六进制：<code>0x11</code></li></ul><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li>空字符串： <code>&#39;&#39;</code></li><li><p>多行字符串： </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> s = <span class="string">`12345</span></span><br><span class="line"><span class="string">67890`</span> <span class="comment">// 含回车符号</span></span><br></pre></td></tr></table></figure></li><li><p>Base64</p><ul><li>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法;Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。</li><li>编码方法：<code>window.btoa(&quot;test&quot;)；//&quot;dGVzdA==&quot;</code></li><li>解码方法：<code>window.atob(&quot;dGVzdA==&quot;);//&quot;test&quot;</code></li></ul></li></ul><h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>true or false</p><h2 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h2><p>都可以表示“没有”，含义非常相似      </p><ul><li>（规范）如果一个变量没有被赋值，那么这个变量的值就是 <code>undefiend</code></li><li>（习俗）如果你想表示一个还没赋值的对象，就用 <code>null</code>。如果你想表示一个还没赋值的字符串/数字/布尔/symbol，就用 <code>undefined</code>（但是实际上你直接 <code>var xxx</code> 一下就行了，不用写 <code>var xxx = undefined</code>）</li><li><code>null</code>是一个表示“空”的对象，转为数值时为0；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code></li><li><code>undefined == null  //true</code></li></ul><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><ul><li><code>object</code> 就是几种基本类型（无序地）组合在一起,可以无限嵌套</li><li><code>object</code> 的 key 一律是字符串，不存在其他类型的 key（ES6中也可以是 Symbol类型的）</li><li><code>object[&#39;&#39;]</code> 是合法的</li><li><code>object[&#39;key&#39;]</code> 可以写作 <code>object.key</code></li><li><code>object.key</code> 与 <code>object[key]</code> 不同</li><li><code>delete object[&#39;key&#39;]</code></li><li><code>&#39;key&#39; in object</code> 用于判断是否存在这个 key</li></ul><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>ES6中新增的一个类型，它是 JavaScript 语言的第七种数据类型，表示独一无二的值。<br>Symbol 值通过Symbol函数生成。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><table><thead><tr><th>类型</th><th>string</th><th>number</th><th>boolean</th><th>symbol</th><th>undefined</th><th>null</th><th>object</th><th>function</th></tr></thead><tbody><tr><td>typeof的值</td><td>‘string’</td><td>‘number’</td><td>‘boolean’</td><td>‘symbol’</td><td>‘undefined’</td><td>‘object’</td><td>‘object’</td><td>‘function’</td></tr></tbody></table><p>1、注意 function 并不是一个类型;<br>2、null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS中的数据类型&quot;&gt;&lt;a href=&quot;#JS中的数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS中的数据类型&quot;&gt;&lt;/a&gt;JS中的数据类型&lt;/h1&gt;&lt;p&gt;七种：&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、 &lt;c
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://blog.yancongwen.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>在WSL中开发Node.js</title>
    <link href="http://blog.yancongwen.com/2018/08/28/%E5%9C%A8WSL%E4%B8%AD%E5%BC%80%E5%8F%91Node-js/"/>
    <id>http://blog.yancongwen.com/2018/08/28/在WSL中开发Node-js/</id>
    <published>2018-08-28T09:19:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WSL-介绍"><a href="#WSL-介绍" class="headerlink" title="WSL 介绍"></a>WSL 介绍</h3><ul><li>WSL(Windows Subsystem for Linux) 适用于Linux的Windows子系统，有了它，不要再安装臃肿的Vmware和VirtualBox等虚机机系统，就可以直接在Windows上体验原生的Linux应用了，甚至还有图形界面！</li><li>WSL是Win10提供的功能，默认关闭，需要去功能管理中开启WSL功能并重启计算机；然后在 Microsoft Store 中搜索 linux 或者 wsl ，会出现几个版本的linux系统供选择，直接安装想要的linux 发型版本即可。我这里安装的是 Ubuntu 18.04.1 LTS，大小约600MB，安装是一键安装的，安装完成直接点击图标即进入linux命令窗口。</li><li>WSL 安装的Linux子系统，拥有独立的目录系统，其目录在C盘中：<code>C:\Users\username\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs</code> 。虽然我们能找到这个目录，但是请不要在Windos中去操作这里的文件！</li><li>个人理解，WSL安装的linux系统，其实仅仅是给了我们一个linux环境，其任然和Winddows系统共享计算机硬件，共享很多东西，比如磁盘、网络端口，linux中的localhost和windows中的localhost一致的。</li></ul><h3 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h3><p>安装的Ubuntu自带git、node，但是版本较低，需要升级。具体方法请自行百度。</p><ul><li>git<br>  git 需要做一些简单的配置，想要以SSH方式连接远程仓库还要生成SSH Key并将公钥配置到远程仓库。这里要注意的是用户权限问题，在linux中不同用户创建的SSH Key并不相同。请看<a href="https://yancongwen.cn/2018/08/23/Error-Permission-denied-publickey/" target="_blank" rel="noopener">另一片文章</a>。</li><li>node</li><li>yarn</li><li>npm</li></ul><h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p>开始，我一直疑虑在WSL中应该以怎样的方式进行node开发。使用vim写代码对于我这种菜鸟还是太费力了，难道我还要在linux中再安装一下图形界面，然后再安装VSCode？不不不。还有一种方式，就是直接使用Windows中的VSCode打开Linux目录下的node项目，也就是直接打开上文提到的藏的很深的那个C盘目录下的项目，但是这种方式也很不优雅，一方面，我们使用window的编辑器去编辑改变linux中的文件，另一方面，我们要在linux中去执行node、yarn、git等命令，并且不能使用VScode去执行命令，不能使用VSCode去调试程序。</p><h3 id="建立软连接"><a href="#建立软连接" class="headerlink" title="建立软连接"></a>建立软连接</h3><p>如上文提及，我们使用VSCode去编辑Linux目录中项目，这个目录藏在C盘很深的位置，不仅占用C盘空间，还不方便管理，可以使用建立软连接的方式来解决。首选我们来看一下什么是软连接、硬连接：    </p><ul><li>软连接：<br>  也叫符号连接（Symbolic Link），软链接文件类似于Windows的快捷方式，它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的文本就是连接的另一文件的位置。    </li><li>硬连接：<br>  硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li></ul><p>我们可以以建立软连接的方式，将F盘的开发目录连接到linux的目录下，这样既可以方便管理开发项目，也可以节省C盘空间占用。</p><ul><li><p>Linux ln 命令创建连接</p><ul><li>命令形式如下： <code>ln  (选项) [源文件] [文件连接]</code>，创建软连接：<code>ln -s \mnt\f\wsl-dev \home\yancongwen\develop</code>     。以上命令就创建了一个软连接，将F盘的目录 wsl-dev 连接到了linux用户目录下的develop，这样我们就可以从linux中的develop访问F盘的开发目录，在linux中，develop目录就形同是一个文件夹，cd 命令可以进入访问。关于ln 命令的更多说明可以看<a href="http://man.linuxde.net/ln" target="_blank" rel="noopener">这里</a>。</li><li>这里也记录一下我踩过的坑：<ul><li>1、ln 命令前一个参数是真实的数据存储所在，后一个参数是连接文件，不要搞反了；刚开始我就是在F盘创建的连接，而目录在linux目录下，显然是不合理的，也没什么用处；</li><li>2、源文件目录和连接文件都一定要采用绝对路径，不要采用<code>~\develop</code>这样的相对路径；我一开始没注意到 <code>~\</code>就是相对路径，所以创建的连接文件一直进不去，把我郁闷坏了。</li></ul></li></ul></li><li><p>windows mklink 命令创建连接<br>windows中同样支持创建软连接和硬连接，使用的是mklink命令。一开始我使用的就是mklink创建的软连接：<code>mklink /D  C:\Users\username\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\yancongwen\develop   F:\wsl-dev</code> （注意，这里前一个路径是连接，后一个连接是源文件），然而，才linux系统中，根本就识别不了这个连接，cd 命令进不去。所以不要使用windows的连接命令去连接linux目录。</p></li></ul><p><strong>【参考】</strong></p><ul><li><a href="https://www.jianshu.com/p/6b02948b3d37" target="_blank" rel="noopener">Win+Linux单系统解决方案——WSL（入门篇）</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">理解 Linux 的硬链接与软链接</a></li><li><a href="https://www.cnblogs.com/kex1n/p/5193826.html" target="_blank" rel="noopener">linux 创建连接命令 ln -s 软链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;WSL-介绍&quot;&gt;&lt;a href=&quot;#WSL-介绍&quot; class=&quot;headerlink&quot; title=&quot;WSL 介绍&quot;&gt;&lt;/a&gt;WSL 介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;WSL(Windows Subsystem for Linux) 适用于Linux的Window
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.yancongwen.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Error: Permission denied (publickey)</title>
    <link href="http://blog.yancongwen.com/2018/08/23/Error-Permission-denied-publickey/"/>
    <id>http://blog.yancongwen.com/2018/08/23/Error-Permission-denied-publickey/</id>
    <published>2018-08-23T11:37:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-Error-Permission-denied-publickey"><a href="#Git-Error-Permission-denied-publickey" class="headerlink" title="Git Error: Permission denied (publickey)"></a>Git Error: Permission denied (publickey)</h2><blockquote><p>最近接触到一个nodejs后端服务项目，项目需要运行在linux环境中，经leader推荐，决定使用Win10的WSL功能，安装了Ubuntu 18.04。在Ubuntu中配置git中遇到了以下问题。</p></blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>Ubuntu中自带了git，但是使用之前需要做一些配置。首先要做的事情就是设置你的名字和邮件地址，此外，使用ssh连接github或者gitlab这些远程仓库需要配置公钥。我按照如下命令生成了SSH Key，生成的密钥在 <code>~/.ssh</code> 文件夹下，将公钥复制到github中即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>然而，当我执行 <code>sudo git clone git@gitlab.com:***.git</code> 时，就失败了，显示如下信息:</p><pre><code>git@gitlab.com: Permission denied (publickey).fatal: Could not read from remote repository.</code></pre><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>上面的信息显示应该是公钥出了问题。反复确认，我的公钥确实没有配置错误啊，而且执行<code>ssh git@gitlab.com</code>的时候确实显示SSH链接已经建立了呀。然而，当我执行<code>sudo ssh git@gitlab.com</code>的时候，同样抛出了<code>Permission denied (publickey)</code>，说明可能和<code>sudo</code> 有关。<br>反反复复查资料，发现也有其他人出现了这个<a href="https://gitlab.com/gitlab-com/support-forum/issues/171" target="_blank" rel="noopener">问题</a>,但是按照里面的方法我并没有解决问题。<br>最后，还是在github的<a href="https://help.github.com/articles/error-permission-denied-publickey/#platform-linux" target="_blank" rel="noopener">帮助文档</a>找到了问题所在。原来，在git命令前加上sudo权限后，使用的密匙就应该是 sudo权限下生成的 SSH Key，这个SSH Key 在<code>\root\.ssh</code>目录下，而我们配置的是<code>~/.ssh</code> 目录下的SSH Key。<br>所以我所做的，就是使用sudo权限重新生成了SSH Key，然后将<code>\root\.ssh</code>目录下的公钥配置到github中，这样再执行<code>sudo git</code>这样的命令就OK了    </p><p><strong>参考</strong></p><ul><li><a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#platform-linux" target="_blank" rel="noopener">Generating a new SSH key and adding it to the ssh-agent</a></li><li><a href="https://help.github.com/articles/error-permission-denied-publickey/#platform-linux" target="_blank" rel="noopener">Error: Permission denied (publickey)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-Error-Permission-denied-publickey&quot;&gt;&lt;a href=&quot;#Git-Error-Permission-denied-publickey&quot; class=&quot;headerlink&quot; title=&quot;Git Error: Permiss
      
    
    </summary>
    
    
      <category term="git" scheme="http://blog.yancongwen.com/tags/git/"/>
    
      <category term="linux" scheme="http://blog.yancongwen.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://blog.yancongwen.com/2018/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.yancongwen.com/2018/07/29/数据结构基础/</id>
    <published>2018-07-29T11:46:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<ul><li>哈希表（Hash Table）<ul><li>计数排序中的桶（复杂度 O(n+max)，比快排还快</li><li>桶排序 与计数排序的区别</li><li>基数排序 与计数排序的区别</li></ul></li><li>队列（Queue）<ul><li>先进先出</li><li>可以用数组实现</li><li>举例：排队</li></ul></li><li>栈（Stack）<ul><li>先进后出</li><li>可以用数组实现</li><li>举例：盗梦空间</li></ul></li><li>链表（Linked List）<ul><li>数组无法直接删除中间的一项，链表可以</li><li>用哈希（JS里面用对象表示哈希）实现链表</li><li>head、node 概念</li></ul></li><li>树（tree）<ul><li>举例：层级结构、DOM</li><li>概念：层数、深度、节点个数</li><li>二叉树</li><li>满二叉树</li><li>完全二叉树</li><li>完全二叉树和满二叉树可以用数组实现</li><li>其他树可以用哈希（对象）实现</li><li>操作：增删改查</li><li>堆排序用到了 tree</li><li>其他：B树、红黑树、AVL树</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;哈希表（Hash Table）&lt;ul&gt;
&lt;li&gt;计数排序中的桶（复杂度 O(n+max)，比快排还快&lt;/li&gt;
&lt;li&gt;桶排序 与计数排序的区别&lt;/li&gt;
&lt;li&gt;基数排序 与计数排序的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;队列（Queue）&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://blog.yancongwen.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数据结构" scheme="http://blog.yancongwen.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CSS总结</title>
    <link href="http://blog.yancongwen.com/2018/07/28/CSS%E6%8A%80%E5%B7%A7/"/>
    <id>http://blog.yancongwen.com/2018/07/28/CSS技巧/</id>
    <published>2018-07-28T07:41:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记录一些CSS中的一些常识和技巧<br>CSS 的学习不需要死记硬背，就是经验和熟练度，要会用工具。比如，要会搜索 “css generator”</p></blockquote><h2 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h2><h3 id="1、文档流"><a href="#1、文档流" class="headerlink" title="1、文档流"></a>1、文档流</h3><ul><li>行内元素</li><li>块级元素</li></ul><h3 id="2、盒模型"><a href="#2、盒模型" class="headerlink" title="2、盒模型"></a>2、盒模型</h3><ul><li>padding</li><li>border</li><li>margin</li></ul><h3 id="3、定位-position"><a href="#3、定位-position" class="headerlink" title="3、定位 position"></a>3、定位 position</h3><ul><li>static<br>默认，没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。     </li><li>relative<br>相对定位，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素原始位置留下空白）</li><li>absolute<br>绝对定位，相对于 static 定位以外的第一个父元素进行定位。    </li><li>fixed<br>固定定位，相对于浏览器窗口进行定位。</li><li>sticky<br>粘性定位，基于用户滚动的位置，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</li></ul><h2 id="二、技巧"><a href="#二、技巧" class="headerlink" title="二、技巧"></a>二、技巧</h2><ul><li>调试技巧：给元素加border;</li><li>浮动，给父元素清除浮动;<br>   .clearfix{<br>   content:’’;<br>   display:block;<br>   clear:both;<br>  }</li><li>不要上来就给div加高度和宽度，要让内容撑开它;<ul><li>div 的高度是由其文档流的高度决定的</li><li>height 和 width 是 bug 的来源</li></ul></li><li>脱离文档流</li></ul><h2 id="三、常用工具网站"><a href="#三、常用工具网站" class="headerlink" title="三、常用工具网站"></a>三、常用工具网站</h2><ul><li><a href="https://css-tricks.com/" target="_blank" rel="noopener">CSS技巧大全 CSS Tricks</a></li><li><a href="http://css3generator.com/" target="_blank" rel="noopener">CSS 代码生成器 CSS3 Generator</a></li><li><a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">CSS 动画生成器 Animate.css</a></li><li><a href="https://www.copypastecharacter.com/" target="_blank" rel="noopener">特殊符号大全</a></li><li><a href="http://browserhacks.com/" target="_blank" rel="noopener">浏览器测试 BROWSERHACKS</a></li><li><a href="http://www.colorzilla.com/gradient-editor/" target="_blank" rel="noopener">获取渐变色 Ultimate CSS Gradient Generator</a></li><li><a href="https://dribbble.com/" target="_blank" rel="noopener">设计社区 dribbble</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记录一些CSS中的一些常识和技巧&lt;br&gt;CSS 的学习不需要死记硬背，就是经验和熟练度，要会用工具。比如，要会搜索 “css generator”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、知识点&quot;&gt;&lt;a href=&quot;#一、知识点
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://blog.yancongwen.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>命令行技巧</title>
    <link href="http://blog.yancongwen.com/2018/07/22/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E5%B7%A7/"/>
    <id>http://blog.yancongwen.com/2018/07/22/命令行技巧/</id>
    <published>2018-07-22T12:36:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技巧一：-bashrc"><a href="#技巧一：-bashrc" class="headerlink" title="技巧一：~/.bashrc"></a>技巧一：~/.bashrc</h2><h3 id="自动运行"><a href="#自动运行" class="headerlink" title="自动运行"></a>自动运行</h3><p>1、首先 <code>touch ~/.bashrc</code> 创建一下这个文件<br>2、<code>start ~/.bashrc</code>选用编辑器编辑这个文件，内容为 <code>echo &#39;Hi&#39;</code><br>3、你也可以用命令行编辑文件 <code>echo &quot;echo &#39;hi&#39;&quot; &gt;&gt; ~/.bashrc</code><br>4、关闭退出 Git Bash，然后打开 Git Bash，是不是看到了 Hi，这说明每次进入 Git Bash，就会优先运行 <code>~/.bashrc</code>里面的命令<br>5、重新编辑<code>~/.bashrc</code>，内容改为<code>cd ~/Desktop</code>，重启 Git Bash，有没有发现默认就进入桌面目录了？<br>你可以用 ~/.bashrc 在进入 Git Bash 前执行任何命令，十分方便。</p><h3 id="alias-别名"><a href="#alias-别名" class="headerlink" title="alias 别名"></a>alias 别名</h3><p>1、 在 ~/.bashrc 里新增一行 <code>alias f=&quot;echo &#39;frank is awesome&#39;&quot;</code>，等于号两边不能有空格，你最好一个字都不要错。<br>2、 运行 <code>source ~/.bashrc</code>，作用是执行 <code>~/.bashrc</code><br>3、 运行 f，就会看到 <code>frank is awesome</code><br>4、 也就是说，现在 f 就是 <code>echo &#39;frank is awesome&#39;</code> 的缩写了，利用这个技巧，我们可以把很多常见的命令缩写一下，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alias la=&apos;ls -a&apos;</span><br><span class="line">alias ll=&apos;ls -l&apos;</span><br><span class="line">alias gst=&apos;git status -sb&apos;</span><br><span class="line">alias ga=&apos;git add&apos;</span><br><span class="line">alias ga.=&apos;git add .&apos;</span><br><span class="line">alias gc=&apos;git commit&apos;</span><br><span class="line">alias gc.=&apos;git commit .&apos;</span><br></pre></td></tr></table></figure></p><p>保存退出，然后运行 source ~/.bashrc<br>5、这样一来，你的 Git 操作就会简单很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ga 1.txt</span><br><span class="line">ga .</span><br><span class="line">gc 1.txt</span><br><span class="line">gc.</span><br><span class="line">gst</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技巧一：-bashrc&quot;&gt;&lt;a href=&quot;#技巧一：-bashrc&quot; class=&quot;headerlink&quot; title=&quot;技巧一：~/.bashrc&quot;&gt;&lt;/a&gt;技巧一：~/.bashrc&lt;/h2&gt;&lt;h3 id=&quot;自动运行&quot;&gt;&lt;a href=&quot;#自动运行&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shadowsocks配置</title>
    <link href="http://blog.yancongwen.com/2018/04/22/shadowsocks/"/>
    <id>http://blog.yancongwen.com/2018/04/22/shadowsocks/</id>
    <published>2018-04-21T17:27:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下Shadowsocks的配置过程</p></blockquote><h3 id="1-通过SSH连接主机"><a href="#1-通过SSH连接主机" class="headerlink" title="1. 通过SSH连接主机"></a>1. 通过SSH连接主机</h3><h3 id="2-安装Shadowsocks"><a href="#2-安装Shadowsocks" class="headerlink" title="2. 安装Shadowsocks"></a>2. 安装Shadowsocks</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># apt-get update                              // 更新源中包列表</span><br><span class="line"># apt-get install python-pip                  // 安装pip</span><br><span class="line"># pip install --upgrade pip                   // 更新pip</span><br><span class="line"># pip install shadowsocks                     // 安装Shadowsocks</span><br></pre></td></tr></table></figure></code></pre><h3 id="3-配置Shadowsocks"><a href="#3-配置Shadowsocks" class="headerlink" title="3. 配置Shadowsocks"></a>3. 配置Shadowsocks</h3><ul><li><p>编辑配置文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure></li><li><p>在文件中输入以下内容，保存</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">     &quot;local_port&quot;:1080,</span><br><span class="line">     &quot;timeout&quot;:600,</span><br><span class="line">     &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">     &quot;port-password&quot;:&#123;</span><br><span class="line">         // 设置端口号和对应的密码，自定义即可</span><br><span class="line">         &quot;9001&quot;:&quot;666666666&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;666666666&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置完成以上内容，就可以运行ss了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-设置开机启动"><a href="#4-设置开机启动" class="headerlink" title="4. 设置开机启动"></a>4. 设置开机启动</h3><ul><li><p>编辑以下文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/rc.local</span><br></pre></td></tr></table></figure></li><li><p>在文件中添加以下内容保存</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一下Shadowsocks的配置过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-通过SSH连接主机&quot;&gt;&lt;a href=&quot;#1-通过SSH连接主机&quot; class=&quot;headerlink&quot; title=&quot;1. 通过SSH连接主机&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.yancongwen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Chorme插件推荐</title>
    <link href="http://blog.yancongwen.com/2018/04/21/chorme-plugs/"/>
    <id>http://blog.yancongwen.com/2018/04/21/chorme-plugs/</id>
    <published>2018-04-21T03:49:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文简单汇总下本人常用的 Chorme 插件，主要是 Web 前端开发中常用开发利器。</p></blockquote><h2 id="1-日常使用"><a href="#1-日常使用" class="headerlink" title="1. 日常使用"></a>1. 日常使用</h2><ul><li>Proxy SwitchyOmega<br>翻\墙必备，控制代理模式，帮助我们合适高效翻\墙,可以自定义翻\墙规则</li><li>谷歌访问助手<br>没有 VPN、Shadowsocks 等翻\墙账号时可以暂时使用这个工具，但是只能满足部分需求，谷歌是可以的，youtube、twitter 这些就不行</li><li>Adblock Plus<br>广告屏蔽插件</li><li>Google学术搜索<br>查论文</li><li>CNKI E-Study<br>配合 CNKI E-Study客户端使用，方便导入论文</li><li>OneTab<br>当打开的标签页太多时，不仅自己不爽，还占电脑内存，此工具可以一键杀死谷歌浏览器中所有标签页，并将杀死的标签页保留，你可以随时恢复</li><li>Save to Pocket<br>轻松保存文章、视频方便以后查看</li><li>有道词典Chrome划词插件<br>网页鼠标划词翻译</li><li>Marinara<br>番茄工作法助理</li><li>极简图床<br>我目前使用的图床工具，配合七牛云使用，可以很方便地复制、拖拽、采集页面的图片到七牛云存储</li><li>新浪微博图床<br>使用微博作为图床，本人之前使用的图床，偶尔会出现图片丢失的情况，现在已经全部转移到七牛云存储（配合极简图床）</li></ul><h2 id="2-Web-开发"><a href="#2-Web-开发" class="headerlink" title="2. Web 开发"></a>2. Web 开发</h2><ul><li>Allow-Control-Allow-Origin: *<br>该插件可谓是前端开发利器，帮助我们解决跨域问题。该插件实现跨域的机制是利用Chrome浏览器开发接口对请求头响应头做了修改。该插件在每次发起请求时，在请求头中添加了请求头 <code>origin:http://evil.com/</code>。详细信息可以参考<a href="https://github.com/vitvad/Access-Control-Allow-Origin/issues/47" target="_blank" rel="noopener">这里</a><br><img src="https://img.yancongwen.cn/18-4-22/61111202.jpg" alt><br><img src="https://img.yancongwen.cn/18-4-22/920590.jpg" alt></li><li>Vue.js devtools<br>Vue 开发必备</li><li>JSON Viewer<br>Json 格式化工具</li><li>LiveReload<br>配合 Sublime Text3 中 LiveReload 插件一起使用，修改代码后会自动刷新浏览器页面</li><li>Octotree<br>在 GitHub 网页展示文件结构</li><li>Tampermonkey<br>浏览器脚本管理工具，非常强大！其中有非常多开源脚本，脚本功能五花八门，只有你想不到的，没有它做不到，有兴趣可以试一下。</li><li>Postman<br>HTTP 请求工具，可以测试开发中后台接口</li><li>ng-inspect for AngularJS<br>AngularJS 开发工具</li><li>AngularJS Batarang<br>AngularJS 开发工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文简单汇总下本人常用的 Chorme 插件，主要是 Web 前端开发中常用开发利器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-日常使用&quot;&gt;&lt;a href=&quot;#1-日常使用&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.yancongwen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="http://blog.yancongwen.com/2018/04/20/%E7%AE%97%E6%B3%95%E5%88%9D%E7%BA%A7/"/>
    <id>http://blog.yancongwen.com/2018/04/20/算法初级/</id>
    <published>2018-04-20T07:29:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>排序是开发中十分常见且核心的操作，虽说实际项目中很小几率会需要我们手动实现，但是了解这些精妙的思想对我们还是大有裨益的。本文简单总结下最基础的几类算法。<br>这里首先推荐一个数据结构和算法动态可视化网站：<a href="https://visualgo.net/zh" target="_blank" rel="noopener">https://visualgo.net/zh</a>    </p></blockquote><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h2><ul><li><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li><li><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。<br><img src="https://img.yancongwen.cn/18-7-29/36420106.jpg" alt></li></ul></li><li><p>算法复杂度<br><img src="https://img.yancongwen.cn/18-7-29/50241781.jpg" alt></p></li><li><p>相关概念</p><ul><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度</strong>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </li><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li></ul></li></ul><h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h2><ul><li>思想<br>  对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。<br>  在冒泡排序的过程中，如果某一趟执行完毕，没有做任何一次交换操作，比如数组<code>[5,4,1,2,3]</code>，执行了两次冒泡之后变为<code>[1,2,3,4,5]</code>。此时，再执行第三次循环后，一次交换都没有做，这就说明剩下的序列已经是有序的，排序提前完成。<br><img src="https://img.yancongwen.cn/18-7-29/39893856.jpg" alt><br><img src="https://img.yancongwen.cn/18-4-25/13811645.jpg" alt="冒泡排序示例"></li><li>算法分析<ul><li>时间复杂度：Ο(n^2)</li><li>空间复杂度：Ο(1)</li></ul></li><li>JS实现    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> i, j, temp, bSwap;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    bSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        bSwap = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于判断此轮循环有没有做交换，如果没有交换，说明数组已经是有序的了，排序完成</span></span><br><span class="line">    <span class="keyword">if</span> (!bSwap)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  交换两个数值的简便方式，接下来的代码就采用此方式：</span></span><br><span class="line"><span class="comment">  [a,b] = [b,a];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-快速排序（Quick-Sort）"><a href="#2-快速排序（Quick-Sort）" class="headerlink" title="2. 快速排序（Quick Sort）"></a>2. 快速排序（Quick Sort）</h2><ul><li>思想<br>  通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br> 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：<ul><li>1、从数列中挑出一个元素，称为 “基准”；</li><li>2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置，这个称为分区操作；</li><li>3、对每个分区不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<br><img src="https://img.yancongwen.cn/18-7-29/2970506.jpg" alt="快速排序"></li></ul></li></ul><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5. 选择排序"></a>5. 选择排序</h2><h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h2><h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><h2 id="8-计数排序（Count-Sort）"><a href="#8-计数排序（Count-Sort）" class="headerlink" title="8. 计数排序（Count Sort）"></a>8. 计数排序（Count Sort）</h2><ul><li>简介<br>  计数排序不是基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，快于任何比较排序算法。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</li><li>思想<ul><li>1、找出待排序的数组中最大和最小的元素；    </li><li>2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<br><img src="https://img.yancongwen.cn/18-7-29/43783126.jpg" alt="计数排序过程动画"><br><img src="https://img.yancongwen.cn/18-7-29/12897429.jpg" alt="基数排序示例说明"></li></ul></li><li><p>算法分析</p><ul><li>时间复杂度：Ο(n+k)，k为待排序数的范围，n为数组长度</li><li>空间复杂度：Ο(k)</li><li>稳定性：稳定</li><li>要求：数值较小的整数数组。计数排序是一种以空间换时间的排序算法，并且只适用于待排序列中所有的数较为集中时。当数组较为分散时，比如一组序列中的数据为<code>0 1 2 3 4 999</code>就得开辟1000个辅助空间，就很不划算。</li></ul></li><li><p>JS实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length,</span><br><span class="line">      Result = [],</span><br><span class="line">      Count = [],</span><br><span class="line">      min = max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'countingSort waste time:'</span>);</span><br><span class="line">  <span class="comment">/*查找最大最小值,并将arr数置入Count数组中,统计出现次数*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    min = min &lt;= arr[i] ? min : arr[i];</span><br><span class="line">    max = max &gt;= arr[i] ? max : arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(Count)</span><br><span class="line">  <span class="comment">/*从最小值-&gt;最大值,将计数逐项相加*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j = min;j&lt;max;j++)&#123;</span><br><span class="line">    Count[j+<span class="number">1</span>] = (Count[j+<span class="number">1</span>]||<span class="number">0</span>)+(Count[j]||<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k = len - <span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">    <span class="comment">/*Result[位置] = arr数据*/</span></span><br><span class="line">    Result[Count[arr[k]] - <span class="number">1</span>] = arr[k];</span><br><span class="line">    <span class="comment">/*减少Count数组中保存的计数*/</span></span><br><span class="line">    Count[arr[k]]--;</span><br><span class="line">    <span class="comment">/*显示Result数组每一步详情*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(Result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">"countingSort waste time:"</span>);</span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;排序是开发中十分常见且核心的操作，虽说实际项目中很小几率会需要我们手动实现，但是了解这些精妙的思想对我们还是大有裨益的。本文简单总结下最基础的几类算法。&lt;br&gt;这里首先推荐一个数据结构和算法动态可视化网站：&lt;a href=&quot;https://visu
      
    
    </summary>
    
      <category term="技术" scheme="http://blog.yancongwen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机基础" scheme="http://blog.yancongwen.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="http://blog.yancongwen.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Centering in CSS</title>
    <link href="http://blog.yancongwen.com/2018/04/19/css-centering/"/>
    <id>http://blog.yancongwen.com/2018/04/19/css-centering/</id>
    <published>2018-04-18T17:29:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 CSS-Tricks 中的一篇文章—— <a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">Centering in CSS: A Complete Guide</a>，CSS居中完全指南，其中有部分删改。</p></blockquote><p>&emsp;&emsp;Centering things in CSS is the poster child of CSS complaining. Why does it have to be so hard? They jeer. I think the issue isn’t that it’s difficult to do, but in that there so many different ways of doing it, depending on the situation, it’s hard to know which to reach for.<br>&emsp;&emsp;居中是一种很常见的布局方式。有人抱怨CSS居中布局很难，其实不然，在我看来，说居中布局难，不是因为居中真的有多么难实现，而是因为实现居中的方法有太多太多，以至于新手总是纠结去用哪个。我们需要根据不同的场景，去选择合适的方法。<br>&emsp;&emsp;本文将CSS居中布局方法进行归类，以便于理解和简化居中问题。</p><h2 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1.水平居中"></a>1.水平居中</h2><h3 id="1-1-行内元素"><a href="#1-1-行内元素" class="headerlink" title="1.1 行内元素"></a>1.1 行内元素</h3><p>行内元素直接为其父元素设置文本居中即可。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center-children</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://codepen.io/chriscoyier/pen/HulzB" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/HulzB</a></p><h3 id="1-2-块级元素"><a href="#1-2-块级元素" class="headerlink" title="1.2 块级元素"></a>1.2 块级元素</h3><p>块级元素直接设置左右边距为 auto 即可，前提是该块级元素必需有 width ，而且必需处于标准文档流中，浮动、绝对定位、固定定位了的元素就不能。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center-me</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/chriscoyier/pen/eszon" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/eszon</a></p><h3 id="1-3-多个块级元素"><a href="#1-3-多个块级元素" class="headerlink" title="1.3 多个块级元素"></a>1.3 多个块级元素</h3><ul><li>多个块元素在一行内居中<ul><li>方法一：父元素设置 text-align: center ，子元素设置 display: inline-block；     </li><li>方法二：使用 flex 布局，父元素设置 display: flex; justify-content: center;</li></ul></li></ul><p><iframe src="https://codepen.io/chriscoyier/embed/ebing" width="100%" height="305" frameborder="0"></iframe></p><ul><li>多个块元素在一列内居中<br>如果只是需要让多个块级元素整体水平居中，并且按默认的方式纵向排列，那直接设置左右边距为 auto 即可。</li></ul><p><iframe src="https://codepen.io/chriscoyier/embed/haCGt" width="100%" height="305" frameborder="0"></iframe></p><h2 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2. 垂直居中"></a>2. 垂直居中</h2><h3 id="2-1-行内元素"><a href="#2-1-行内元素" class="headerlink" title="2.1 行内元素"></a>2.1 行内元素</h3><ul><li>单行居中<ul><li>设置行高与元素的高度相同<br><a href="https://codepen.io/chriscoyier/pen/LxHmK" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/LxHmK</a></li><li>为行内元素/文本元素设置相等的上下内边距<br><a href="https://codepen.io/chriscoyier/pen/ldcwq" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/ldcwq</a></li></ul></li><li>多行居中<ul><li>设置相等的上下内边距</li><li>vertical-align 属性来实现垂直居中<br>  <a href="https://codepen.io/chriscoyier/pen/ekoFx" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/ekoFx</a></li><li>flexbox<br><a href="https://codepen.io/chriscoyier/pen/uHygv" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/uHygv</a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-center-vertically</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-2-块级元素"><a href="#2-2-块级元素" class="headerlink" title="2.2 块级元素"></a>2.2 块级元素</h3><ul><li><p>元素高度已知</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>; <span class="comment">/* account for padding and border if not using box-sizing: border-box; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <a href="https://codepen.io/chriscoyier/pen/HiydJ" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/HiydJ</a></p></li><li><p><strong>元素高度未知</strong>（最常见的一种场景）</p><ul><li><p>方法一：先将元素相对于其原始位置向下移动父元素高度的一半距离，再将该元素相对其本身的高度向上移动一半，这样就能实现垂直居中的效果了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <a href="https://codepen.io/chriscoyier/pen/lpema" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/lpema</a></p></li><li><p>方法二：flexbox</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <a href="https://codepen.io/chriscoyier/pen/FqDyi" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/FqDyi</a></p></li></ul></li></ul><h2 id="3-垂直和水平都居中"><a href="#3-垂直和水平都居中" class="headerlink" title="3. 垂直和水平都居中"></a>3. 垂直和水平都居中</h2><p>当然，我们可以结合以上给出的方法来实现垂直和水平方向都居中的布局。这里我们再进行一下分类总结。</p><h3 id="3-1-宽高固定"><a href="#3-1-宽高固定" class="headerlink" title="3.1 宽高固定"></a>3.1 宽高固定</h3><p>将元素相对于其父元素的宽度/高度值向右并向下移动一半的距离，然后再通过设置负边距值的方法，将元素相对于其自身的宽度/高度值向左并向上移动一半的距离，就可实现水平垂直均居中的效果了。并且这种方法的浏览器兼容性是很好的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">70px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">170px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://codepen.io/chriscoyier/pen/JGofm" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/JGofm</a></p><h3 id="3-2-宽高不固定"><a href="#3-2-宽高不固定" class="headerlink" title="3.2 宽高不固定"></a>3.2 宽高不固定</h3><p>如果元素的宽度或者高度未知，则在将元素相对于父元素的宽高往向右并向下移动一半距离后，再用 <code>transform</code> 属性来将其向左并向上移动自身宽度及高度值一半的距离即可。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://codepen.io/chriscoyier/pen/lgFiq" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/lgFiq</a></p><h3 id="3-3-使用-flexbox"><a href="#3-3-使用-flexbox" class="headerlink" title="3.3 使用 flexbox"></a>3.3 使用 flexbox</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/chriscoyier/pen/msItD" target="_blank" rel="noopener">https://codepen.io/chriscoyier/pen/msItD</a></p><h3 id="3-4-使用-grid"><a href="#3-4-使用-grid" class="headerlink" title="3.4 使用 grid"></a>3.4 使用 grid</h3><p>这只是一个小技巧，只适用于一个元素的情况。</p><p><iframe src="https://codepen.io/chriscoyier/embed/NvwpyK" width="100%" height="305" frameborder="0"></iframe></p><h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4. 结束语"></a>4. 结束语</h2><p>CSS 还是很伟大的，能够实现的布局多种多样，实现的方法也多种多样，重要的是找到合适的方法！这就需要多写多练多总结！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自 CSS-Tricks 中的一篇文章—— &lt;a href=&quot;https://css-tricks.com/centering-css-complete-guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cent
      
    
    </summary>
    
      <category term="技术" scheme="http://blog.yancongwen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSS" scheme="http://blog.yancongwen.com/tags/CSS/"/>
    
      <category term="译文" scheme="http://blog.yancongwen.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Git基础</title>
    <link href="http://blog.yancongwen.com/2018/04/15/Git%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.yancongwen.com/2018/04/15/Git基础/</id>
    <published>2018-04-15T13:37:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、工作区、暂存区、版本库、远程库"><a href="#1、工作区、暂存区、版本库、远程库" class="headerlink" title="1、工作区、暂存区、版本库、远程库"></a>1、工作区、暂存区、版本库、远程库</h2><ul><li>工作区（Working Directory）<br>  就是你在电脑里能看到的目录</li><li>版本库（Repository）<br>  工作区有一个隐藏目录.git就是版本库。</li><li>暂存区<br>  Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 maste r的一个指针叫HEAD。</li><li>远程库<br>  指 github 或码云等 git 服务器上的版本库，也可以自己搭建 git 服务器。</li></ul><h2 id="2、常用命令"><a href="#2、常用命令" class="headerlink" title="2、常用命令"></a>2、常用命令</h2><ul><li>git init：初始化一个Git仓库</li><li>git add：把文件修改添加到暂存区，可反复多次使用，添加多个文件<ul><li>git add -A   // 添加所有改动</li><li>git add *    //加新建文件和修改，但是不包括删除</li><li>git add .    //加新建文件和修改，但是不包括删除</li><li>git add -u   //加修改和删除，但是不包括新建文件</li></ul></li><li>git commit：提交更改，把暂存区的所有内容提交到当前分支</li><li>git status：查看仓库当前的状态<ul><li>-s：以简洁的形式显示</li><li>-b：也显示分支的状态 </li></ul></li><li>git diff：查看改变</li><li>git log：查看提交历史</li><li>git reflog：查看命令历史<ul><li>–pretty=oneline 一行显示 </li></ul></li><li>git reset：回退到指定版本。HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id</li><li><p>git clone :克隆远程库</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SSH加密</span><br><span class="line">git clone git@github.com:yancongwen/仓库名.git</span><br><span class="line">// HTTPS加密，采用此协议的话以后每次推送都要登陆，比较繁琐</span><br><span class="line">git clone https://github.com/yancongwen/仓库名.git</span><br><span class="line">// 克隆分支: </span><br><span class="line">git clone -b &lt;branch name&gt; [remote repository address].git</span><br><span class="line">// 或者：</span><br><span class="line">git clone &lt;respository-name&gt;,先克隆库</span><br><span class="line">git checkout &lt;branchname&gt;,检出分支</span><br><span class="line">git pull 取回远程主机某个分支的更新，再与本地的指定分支合并</span><br></pre></td></tr></table></figure></li><li><p>git pull: 取回远程主机某个分支的更新，再与本地的指定分支合并</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line">// 例：</span><br><span class="line">$ git pull origin next:master </span><br><span class="line">// 取回origin主机的next分支，与本地的master分支合并</span><br></pre></td></tr></table></figure></li><li><p>git push：将本地分支的更新，推送到远程主机</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3、命令"><a href="#3、命令" class="headerlink" title="3、命令"></a>3、命令</h2><p><img src="https://upload-images.jianshu.io/upload_images/3731280-8f32b6551e73d878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git命令.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3731280-6c1704b05d8391d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git常用命令图解.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3731280-2d0e8582ee365ea1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git命令.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、工作区、暂存区、版本库、远程库&quot;&gt;&lt;a href=&quot;#1、工作区、暂存区、版本库、远程库&quot; class=&quot;headerlink&quot; title=&quot;1、工作区、暂存区、版本库、远程库&quot;&gt;&lt;/a&gt;1、工作区、暂存区、版本库、远程库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工作区（
      
    
    </summary>
    
    
      <category term="git" scheme="http://blog.yancongwen.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>HTTP总结（前端开发中的常识性问题）</title>
    <link href="http://blog.yancongwen.com/2018/04/11/HTTP%E6%80%BB%E7%BB%93--%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%AF%86%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.yancongwen.com/2018/04/11/HTTP总结--前端开发中的常识性问题/</id>
    <published>2018-04-11T05:33:00.000Z</published>
    <updated>2019-03-28T06:16:34.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-TCP-IP-简介"><a href="#1-TCP-IP-简介" class="headerlink" title="1. TCP/IP 简介"></a>1. TCP/IP 简介</h2><ul><li>首先应该理解 TCP/IP 协议族中的四个分层：应用层、传输层、网络层、数据链路层，详细请看另一篇<a href="http://blog.yancongwen.cn/2018/01/08/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">博客</a>。<ul><li>HTTP 位于应用层，负责生成或解析报文</li><li>TCP、UDP 位于传输层，负责将报文方便、可靠得传输</li><li>IP 位于网络层，负责搜索地址、路由中转、传输</li><li>数据链路层是硬件设备</li></ul></li></ul><h2 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h2><ul><li>HyperText Transfer Protocol，超文本转移协议，是TCP/IP 协议族的子集，用于客户端和 服务器之间的通信。详细请看其他文章：<a href="http://blog.yancongwen.cn/2018/01/09/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">HTTP基础</a>、<a href="http://blog.yancongwen.cn/2018/01/10/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AHTTP%E6%8A%A5%E6%96%87/" target="_blank" rel="noopener">HTTP报文</a>、<a href="http://blog.yancongwen.cn/2018/01/11/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81/" target="_blank" rel="noopener">HTTP状态码</a>、<a href="http://blog.yancongwen.cn/2018/01/12/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AHTTP%E9%A6%96%E9%83%A8/" target="_blank" rel="noopener">HTTP首部</a>。</li><li>请求报文<br><img src="http://img.yancongwen.cn/18-4-13/64617528.jpg" alt></li><li>响应报文<br><img src="http://img.yancongwen.cn/18-4-13/27833394.jpg" alt></li><li>Chrome开发者工具查看 HTTP 报文<ul><li>① 打开 Network    </li><li>② 地址栏输入网址   </li><li>③ 在 Network 点击，查看 Request/Response Headers，点击「view source」    </li></ul></li></ul><h2 id="3-TCP、UDP"><a href="#3-TCP、UDP" class="headerlink" title="3. TCP、UDP"></a>3. TCP、UDP</h2><ul><li>TCP（三次握手，四次挥手）<ul><li>可靠：三次握手、四次挥手；</li><li>字节流服务：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理；</li><li>可靠、面向连接、相对 UDP 较慢；</li></ul></li><li>UDP <ul><li>不可靠，不面向连接、相对 TCP 较快</li></ul></li></ul><h2 id="4-curl-命令的使用"><a href="#4-curl-命令的使用" class="headerlink" title="4. curl 命令的使用"></a>4. curl 命令的使用</h2><ul><li>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。</li><li><p>语法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl [option] [url]</span><br></pre></td></tr></table></figure></li><li><p>常见参数</p><ul><li>-s ：silent，安静模式，不显示过程或错误信息</li><li>-v ：verbose，显示请求和响应报文</li><li>-I ：head，仅仅显示响应报文，不显示请求返回的内容</li><li>-i ：include，显示响应报文</li><li>-H ：header，增加请求时的请求头信息</li><li>-X ：request，自定义请求方法，默认为GET</li><li>-d ：data，定义POST请求中发送的数据</li><li>-A ：agent，自定义User-Agent用户代理</li><li>-o : output，保存到指定文件</li></ul></li><li><p>示例</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 最简单用法，显示请求过程和请求结果</span><br><span class="line">$ curl www.baidu.com    </span><br><span class="line"></span><br><span class="line">// 最常用用法，显示请求报文、响应报文、请求结果</span><br><span class="line">$ curl -s -v www.baidu.com  </span><br><span class="line"></span><br><span class="line">// 自定义用POST方法进行HTTP通信，并添加自定义请求头</span><br><span class="line">$ curl -X POST -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot;   </span><br><span class="line"></span><br><span class="line">// 发送数据</span><br><span class="line">$ curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot; </span><br><span class="line"></span><br><span class="line">// 下载文件保存到本地指定文件</span><br><span class="line">$ curl http://www.baidu.com &gt; index.html</span><br><span class="line">$ curl -o index.html http://www.baidu.com</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-TCP-IP-简介&quot;&gt;&lt;a href=&quot;#1-TCP-IP-简介&quot; class=&quot;headerlink&quot; title=&quot;1. TCP/IP 简介&quot;&gt;&lt;/a&gt;1. TCP/IP 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先应该理解 TCP/IP 协议族中的四个分层：应用
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://blog.yancongwen.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>命令行基础</title>
    <link href="http://blog.yancongwen.com/2018/03/31/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.yancongwen.com/2018/03/31/命令行基础/</id>
    <published>2018-03-30T17:00:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<p>首先，推荐一个网站<a href="https://explainshell.com/" target="_blank" rel="noopener">explainshell.com</a>，超级强大的Linux命令解释工具，在搜索框里任意输入Linux命令，系统会将命令解析。</p><h2 id="1-常用单词及缩写"><a href="#1-常用单词及缩写" class="headerlink" title="1.常用单词及缩写"></a>1.常用单词及缩写</h2><table><thead><tr><th>英文</th><th>翻译</th></tr></thead><tbody><tr><td>directory</td><td>目录、文件夹</td></tr><tr><td>file</td><td>文件</td></tr><tr><td>make</td><td>新建</td></tr><tr><td>remove</td><td>删除</td></tr><tr><td>move</td><td>移动</td></tr><tr><td>copy</td><td>复制</td></tr><tr><td>list</td><td>罗列</td></tr><tr><td>link</td><td>链接</td></tr><tr><td>find</td><td>查找</td></tr><tr><td>echo</td><td>发出回音、重复</td></tr><tr><td>touch</td><td>触摸</td></tr><tr><td>change</td><td>改变   </td></tr></tbody></table><p>缩写</p><table><thead><tr><th>命令</th><th>全写</th><th>缩写 </th></tr></thead><tbody><tr><td>创建目录</td><td>make directory</td><td>mkdir</td></tr><tr><td>删除</td><td>remove</td><td>rm</td></tr><tr><td>移动 / 重命名</td><td>move</td><td>mv</td></tr><tr><td>复制</td><td>copy</td><td>cp</td></tr><tr><td>罗列</td><td>list</td><td>ls</td></tr><tr><td>改变目录</td><td>change directory</td><td>cd</td></tr></tbody></table><h2 id="2-常见的自带命令"><a href="#2-常见的自带命令" class="headerlink" title="2.常见的自带命令"></a>2.常见的自带命令</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>进入目录</td><td>cd</td></tr><tr><td>显示当前目录</td><td>pwd</td></tr><tr><td>创建目录</td><td>mkdir 目录名</td></tr><tr><td>创建目录</td><td>mkdir -p 目录路径</td></tr><tr><td>显示用户名</td><td>whoami</td></tr><tr><td>查看路径</td><td>ls 路径</td></tr><tr><td>查看路径</td><td>ls -a 路径</td></tr><tr><td>查看路径</td><td>ls -l 路径</td></tr><tr><td>查看路径</td><td>ls -al 路径</td></tr><tr><td>创建文件</td><td>echo ‘1’ &gt; 文件路径</td></tr><tr><td>强制创建文件</td><td>echo ‘1’ &gt;! 文件路径</td></tr><tr><td>追加文件内容</td><td>echo ‘1’ &gt;&gt; 文件路径</td></tr><tr><td>创建文件</td><td>touch 文件名</td></tr><tr><td>改变文件更新时间</td><td>touch 文件名</td></tr><tr><td>复制文件</td><td>cp 源路径 目标路径</td></tr><tr><td>复制目录</td><td>cp -r 源路径 目标路径</td></tr><tr><td>移动节点</td><td>mv 源路径 目标路径</td></tr><tr><td>删除文件</td><td>rm 文件路径</td></tr><tr><td>强制删除文件</td><td>rm -f 文件路径</td></tr><tr><td>删除目录</td><td>rm -r 目录路径</td></tr><tr><td>强制删除目录</td><td>rm -rf 目录路径</td></tr><tr><td>查看目录结构</td><td>tree</td></tr><tr><td>建立软链接</td><td>ln -s 真实文件 链接</td></tr><tr><td>下载文件</td><td>curl -L <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> &gt; baidu.html</td></tr><tr><td>拷贝网页</td><td>wget -p -H -e robots=off <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></td></tr><tr><td>磁盘占用</td><td>df -kh</td></tr><tr><td>当前目录大小</td><td>du -sh </td></tr><tr><td>各文件大小</td><td>du -h</td></tr><tr><td>显示当前用户</td><td>whoami</td></tr><tr><td>显示命令路径</td><td>where name</td></tr><tr><td>查找命令路径</td><td>which name</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，推荐一个网站&lt;a href=&quot;https://explainshell.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;explainshell.com&lt;/a&gt;，超级强大的Linux命令解释工具，在搜索框里任意输入Linux命令，系统会将命令
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://blog.yancongwen.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP学习笔记(七)：HTTPS</title>
    <link href="http://blog.yancongwen.com/2018/01/12/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83--HTTPS/"/>
    <id>http://blog.yancongwen.com/2018/01/12/图解HTTP学习笔记七--HTTPS/</id>
    <published>2018-01-12T12:00:00.000Z</published>
    <updated>2019-03-28T06:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HTTP-的缺点"><a href="#1-HTTP-的缺点" class="headerlink" title="1. HTTP 的缺点"></a>1. HTTP 的缺点</h3><ul><li>通信使用明文（不加密），内容可能会被窃听；</li><li>不验证通信方的身份，因此有可能遭遇伪装（ DoS 攻击，拒绝服务攻击）；</li><li>无法证明报文的完整性，所以有可能已遭篡改（中间人攻击，MITM）；</li></ul><h3 id="2-HTTPS-是身披-SSL-外壳的-HTTP"><a href="#2-HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="2. HTTPS 是身披 SSL 外壳的 HTTP"></a>2. HTTPS 是身披 SSL 外壳的 HTTP</h3><ul><li>HTTPS =  HTTP + 加密 + 认证 + 完整性保护</li></ul><p>&emsp;&emsp;HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。<br>&emsp;&emsp;SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是 当今世界上应用最为广泛的网络安全技术。</p><h3 id="3-相互交换密钥的公开密钥加密技术"><a href="#3-相互交换密钥的公开密钥加密技术" class="headerlink" title="3. 相互交换密钥的公开密钥加密技术"></a>3. 相互交换密钥的公开密钥加密技术</h3><ul><li>共享密钥加密<br><img src="https://img.yancongwen.cn/18-4-13/24308001.jpg" alt></li><li>使用两把密钥的公开密钥加密<br><img src="https://img.yancongwen.cn/18-4-13/24663158.jpg" alt></li><li>HTTPS 采用混合加密机制<br><img src="https://img.yancongwen.cn/18-4-13/12998415.jpg" alt></li></ul><h3 id="4-证明公开密钥正确性的证书"><a href="#4-证明公开密钥正确性的证书" class="headerlink" title="4. 证明公开密钥正确性的证书"></a>4. 证明公开密钥正确性的证书</h3><p>&emsp;&emsp;遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。<br><img src="https://img.yancongwen.cn/18-4-13/27377590.jpg" alt></p><h3 id="5-HTTPS-的安全通信机制"><a href="#5-HTTPS-的安全通信机制" class="headerlink" title="5. HTTPS 的安全通信机制"></a>5. HTTPS 的安全通信机制</h3><p><img src="https://img.yancongwen.cn/18-4-13/6832010.jpg" alt></p><h3 id="6-HTTPS-缺点"><a href="#6-HTTPS-缺点" class="headerlink" title="6. HTTPS 缺点"></a>6. HTTPS 缺点</h3><ul><li>消耗更多 CPU 及内存等资源，导致处理速度变慢；</li><li>和HTTP相比，SSL 通信使通信量会增加；</li><li>HTTPS 比 HTTP 要慢 2 到 100 倍；</li><li>证书必须向认证机构（CA）购买；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-HTTP-的缺点&quot;&gt;&lt;a href=&quot;#1-HTTP-的缺点&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP 的缺点&quot;&gt;&lt;/a&gt;1. HTTP 的缺点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文（不加密），内容可能会被窃听；&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://blog.yancongwen.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
