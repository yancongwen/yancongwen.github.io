{"meta":{"title":"码字仓颉","subtitle":"个人博客","description":"yancongwen'blog","author":"Yan Congwen","url":"http://blog.yancongwen.com"},"pages":[{"title":"About","date":"2018-04-20T03:52:26.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"about/index.html","permalink":"http://blog.yancongwen.com/about/index.html","excerpt":"","text":"欢迎来到我的个人博客"},{"title":"categories","date":"2018-01-31T09:21:14.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"categories/index.html","permalink":"http://blog.yancongwen.com/categories/index.html","excerpt":"","text":""},{"title":"Project","date":"2019-03-28T06:16:34.351Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"project/index.html","permalink":"http://blog.yancongwen.com/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-03-28T06:16:34.367Z","updated":"2019-03-28T06:16:34.367Z","comments":true,"path":"tags/index.html","permalink":"http://blog.yancongwen.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"四大WebGIS地图引擎的对比选择","slug":"四大WebGIS地图引擎的对比选择","date":"2018-11-05T04:42:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/11/05/四大WebGIS地图引擎的对比选择/","link":"","permalink":"http://blog.yancongwen.com/2018/11/05/四大WebGIS地图引擎的对比选择/","excerpt":"","text":"四大Webgis地图引擎的对比选择 选择的方式主要是根据业务需求，主要分为: 传统GIS业务(Leaflet)，三维业务(Cesium)，互联网展示型(MapboxGL)，老IE浏览器，老业务维护(OpenLayers)。 1、Leafletleaflet是常规的的最适合常规gis开发的地图，因此核心功能就是“传统GIS”功能. 优点 主流投影坐标支持：几乎所有的主流投影坐标系都可以支持; 矢量表达：矢量专题图，矢量空间分析，矢量瓦片，矢量可视化等矢量表达; 全样式表达：可结合主流的互联网可视化技术，如D3,Echarts,Mapv，几乎主要的地图的可视化表达都可以实现; 功能全，操作友好：功能全，插件丰富，社区生态完善.出现bug几乎百度找到，对开发者友好; 跨平台：兼容大部分浏览器，跨平台强; 移动设备的支持：内部代码框架设计的时候考虑到移动设备的支持.针对移动设备天然支持; 缺点 没有使用webgl进行渲染，在可视化表达上差一点点; 没有使用硬件加速，在数据量上没有发挥硬件的最大效果; 2、Openlayersopenlayers强调的是老ie等浏览器的兼容性. 优点 主流投影坐标系支持：几乎所有的主流投影坐标系都可以支持; 脚本一体化：功能全并且集成到官方脚本; ogc协议：几乎是最遵循ogc协议的脚本了; 兼容性：兼容老的ie6789等疑难浏览器问题; 缺点 功能大而虚，很多功能有实现但是实际使用效果不理想; 可视化表达差劲; 内存释放与优化差; 3、Mapbox GLMapbox GL主要是构建世界上最漂亮的地图，因此核心功能就是一个“看”字.相关可视化库还有：Kepler-GL、Echarts-GL 优点 高效矢量瓦片：真正高效实用的矢量瓦片; 顶级可视化：真正顶级的可视化渲染，mapboxGL，echartGL，KeplerGl等; 高清矢量图形：真正顶级的高清矢量图形绘制SVG，Canvas; 顶级互联网技术加持：国内Baidu，国外Uber，Mapbox等顶级可视化巨头技术加持; 缺点 只支持web墨卡托投影(EPSG：3857); 三维表达局限于高程和基本高程无法支持浮空真三维模型，这就是mapbox的关于三维的设置项叫做fill-extrusion而不是model的原因; 4、CesiumCesium强调的是BIM三维模型，倾斜摄影的表达，重点在于三维建模与时态模拟.Cesium相关资料汇总 优点 倾斜摄影：支持倾斜摄影，地形，海洋环境等三维场景展现; BIM三维建模：支持BIM管网建模和3dx,gltf模型的展示; 时态表达：支持时态，时间播放，时间动画，时空聚类等时空展现; 缺点 没有类似unity的特殊光晕效果，虽然使用了webgl但效果平平; 自成体系的模型与几何绘制策略，需要重新学习; 代码过重，并且主视图必须获取顶级div，影响工程代码结构;","categories":[],"tags":[{"name":"gis","slug":"gis","permalink":"http://blog.yancongwen.com/tags/gis/"}]},{"title":"HTTP 网络请求参数中带有特殊符号相关问题","slug":"http网络请求参数中带有特殊符号相关问题","date":"2018-10-21T05:21:33.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/10/21/http网络请求参数中带有特殊符号相关问题/","link":"","permalink":"http://blog.yancongwen.com/2018/10/21/http网络请求参数中带有特殊符号相关问题/","excerpt":"","text":"HTTP 网络请求参数中带有特殊符号相关问题1、GET 请求参数中带有空格请求参数中带有空格会被处理为+号。这是HTML4标准中定义的，请看这里Form content types。在HTTP请求头中，首部字段Content-type用于指示资源的MIME类型，规定了提交表单元素时对数据的处理方式。下面是几个常见的值：1.text/html2.text/plain3.text/css4.text/javascript5.application/x-www-form-urlencoded6.multipart/form-data7.application/json8.application/xml…其中application/x-www-form-urlencoded是默认值，使用该值时，提交表单时内容会按照如下规则编码：空格转换为+号；非法字符转换为类似于%E0的两位16进制表示的ASCII码；换行符被转换为CR LF；数据项名称和数据值以=号分割，数据项与数据项之间以&amp;分割；…….按照以上规则，在GET请求中，我们的请求参数会按照以上编码规则进行编码，然后拼接到请求URL后面。例如：12345678$.ajax(&#123; type： 'GET', url: \"http://ip:port/count\", data: &#123; app: '互联网 举证' &#125;, success: function(response)&#123; console.log(response) &#125;&#125;) 当我们发起以上请求时，请求参数会进行转码后拼接在 url 后面，空格被转换为了+号，真正的请求 URI 为 http://ip:port/count?app=app=%E4%BA%92%E8%81%94%E7%BD%91+%E4%B8%BE%E8%AF%81当我们直接在浏览器地址栏中输入请求地址，如下图（%20就是输入的空格），浏览器就会去请求你输入的地址，而不会再将特殊字符转码。但是会将中文转码。（其实相当于执行了JS中的encodeURI） 2、GET 请求参数中带有 + 号+ 号和汉字一样，会被转码，转码后为 %2B。例如：12345678$.ajax(&#123; type： 'GET', url: \"http://ip:port/count\", data: &#123; app: '互联网+举证' &#125;, success: function(response)&#123; console.log(response) &#125;&#125;) 当我们发起以上请求时，请求参数会进行转码后拼接在 url 后面，+号被转为%2B,真正的请求 URI 为 http://ip:port/count?app=%E4%BA%92%E8%81%94%E7%BD%91%2B%E4%B8%BE%E8%AF%81直接在浏览器地址栏中输入请求地址，参数中带有+号，真实请求中就会保留+号。 请细细品味这这几个示例的区别。 3、JavaScript中的 URI 编码解码方法 encodeURI 该方法用于将一个完整的URI编码，该方法不会对那些保留的并且在URI中有特殊意思的字符进行编码； decodeURI 该方法解码一个由encodeURI先前创建的统一资源标识符（URI）； encodeURIComponent 对统一资源标识符（URI）的组成部分进行编码的方法。转义除了字母、数字、(、)、.、!、~、*、&#39;、-和_之外的所有字符。 对于 application/x-www-form-urlencoded (POST) 这种数据方式，空格需要被替换成 ‘+’，所以通常使用 encodeURIComponent 的时候还会把 “%20” 替换为 “+”。参考 decodeURIComponent 用于解码由encodeURIComponent或者其它类似方法编码的部分统一资源标识符（URI）。","categories":[],"tags":[]},{"title":"理解 jQuery","slug":"jquery","date":"2018-10-21T05:20:10.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/10/21/jquery/","link":"","permalink":"http://blog.yancongwen.com/2018/10/21/jquery/","excerpt":"","text":"理解 jQuery1、还有必要学习 jQuery 吗首先必须肯定的回答：有必要。虽然目前 MVVM 框架很流行，但 jQuery 依然占据一定地位。某些特定场景的项目 jQuery 依然是最好的选择，jQuery帮助我们解决了太多的兼容性问题，而且对于有一定JS基础的人来说学习 jQuery 的成本很低，没必要去掌握全部API，只要会查文档就可以。虽然新项目中不一定会使用 jQuery ，但是学习 jQuery ，尤其是去阅读 jQuery 源码，理解其设计思想、设计模式，你将会颇有收获。 2、jQuery DOM 操作设计思想jQuery 的基本设计思想和主要用法，就是”选择某个网页元素，然后对其进行某种操作”。使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery()（简写为$），得到被选中的元素，选中的元素可能是一个，也可能是多个。第二步就是对这些元素进行一系列操作，例如添加class、移除class、取值和赋值、移动等。 jQuery的一大特点就是支持链式操作，即类似于这样$(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;Hello&#39;);,将一系列操作连接在一起。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。 3、自己实现一个简单的 jQuery123456789101112131415161718192021222324252627282930313233window.jQuery = function(nodeOrSelector) &#123; var nodes = &#123;&#125;; if (typeof nodeOrSelector === 'string') &#123; var nodeList = document.querySelectorAll(nodeOrSelector); nodeList.forEach(function(item,index)&#123; nodes[index] = item; &#125;); nodes.length = nodeList.length; &#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; '1': nodeOrSelector, lenght: 1 &#125;; &#125; nodes.addClass = function(classNames)&#123; for (var i=0; i&lt;nodes.length; i++) &#123; classNames.forEach(function(item)&#123; nodes[i].classList.add(item); &#125;); &#125; &#125;; nodes.setText = function(text) &#123; for (var i=0; i&lt;nodes.length; i++) &#123; nodeList[i].innerHTML = text; &#125; &#125;; return nodes;&#125;;// aliaswindow.$ = jQuery// 使用$('ul&gt;li').addClass(['red','blue']);$('ul&gt;li').setText('Hello jQuery'); 以上是本人实现的一个简单的jQuery对象。该对象接收一个参数，可以是一个已经获取到的DOM对象，也可以是一个选择器字符串。jQuery方法返回的是一个自定义的节点对象，该对象上定义了addClass、setText等一系列操作方法。 4、jQuery获取DOM和JS选择器获取的DOM的区别与联系例如：1&lt;div id='x'&gt;&lt;/div&gt; 12var div = document.getElementById('x')var $div = $('#x') div 是由原生API获取的元素节点对象， div.__proto__ === HTMLDivElement.prototype div.__proto__.__proto__ === HTMLElement .prototype $div 是jQuery对象实例，它包含了从jQuery继承过来的很多方法和属性 $div.__proto__ === jQuery.prototype $div.__proto__ .__proto__ === Object.prototype div 变成 $div: $(div) $div 变成 div: $div[0] === div","categories":[],"tags":[]},{"title":"git提交信息规范化","slug":"git提交信息规范化","date":"2018-10-12T06:37:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/10/12/git提交信息规范化/","link":"","permalink":"http://blog.yancongwen.com/2018/10/12/git提交信息规范化/","excerpt":"","text":"git commit 信息规范化1、前言&emsp;&emsp;Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。1$ git commit -m &quot;hello world&quot; &emsp;&emsp;上面代码的-m参数，就是用来指定 commit mesage 的。如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行。&emsp;&emsp;git 并没有规定你提交信息的内容和格式，但是，一个好的项目，一定要有一个自己的统一的提交格式，以便于后期回顾代码。目前，社区有多种 Commit message 的写法规范。本文介绍Angular 规范，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。 2、规范&emsp;&emsp;每次提交，Commit message 都包括三个部分：Header（必需），Body（可选） 和 Footer（可选）。12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; Header 部分只有一行，包括三个字段： type（必需） 用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 scope（可选）用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject（必需）是 commit 目的的简短描述，不超过50个字符。 Body 部分是对本次 commit 的详细描述 Footer 部分只用于两种情况（详细请看阮一峰博客） 不兼容变动 关闭 Issue 3、设置 git commit 模板&emsp;&emsp;如果你只是个人的项目, 或者想尝试一下这样的规范格式, 那么你可以为 git 设置 commit template, 每次 git commit 的时候在 vim 中带出, 以时刻提醒自己提交规范。修改 ~/.gitconfig, 添加:12[commit]template = ~/.gitmessage &emsp;&emsp;新建 ~/.gitmessage 内容可以如下:1234567891011121314# head: (): # - type: feat, fix, docs, style, refactor, test, chore# - scope: can be empty (eg. if the change is a global or difficult to assign to a single component)# - subject: start with verb (such as &apos;change&apos;), 50-character line## body: 72-character wrapped. This should answer:# * Why was this change necessary?# * How does it address the problem?# * Are there any side effects?## footer: # - Include a link to the ticket, if any.# - BREAKING CHANGE# &emsp;&emsp;按照以上方式设置以后，每次执行 git commit 命令提交时进入 vim 编辑器，就会出现提交规范提示信息。 4、工具：Commitizen&emsp;&emsp;Commitizen 是一个帮助我们撰写合格 Commit message 的工具。它提供一个交互式的命令行工具 commitizen/cz-cli 帮助我们生成符合规范的 commit message。除此之外, 我们还需要为 commitizen 指定一个 Adapter 比如: cz-conventional-changelog (一个符合 Angular团队规范的 preset). 使得 commitizen 按照我们指定的规范帮助我们生成 commit message. 4.1 全局安装和使用 全局安装12npm install -g commitizen cz-conventional-changelogecho &apos;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&apos; &gt; ~/.czrc 全局模式下, 需要 ~/.czrc 配置文件, 为 commitizen 指定 Adapter 使用&emsp;&emsp;如果全局安装过 commitizen, 那么在对应的项目中执行 git cz 或者 npm run commit 来替代 git commit 就可以了。执行命令后会进入一个交互式的命令环境，按照提示填写内容就可以了。如图： 提示：如果你是在Windows中使用 Git Bash 执行命令，交互提示符并不工作。你必须通过 winpty git cz 启动这个命令。 4.2 项目级安装和使用1npm install -D commitizen cz-conventional-changelog package.json中配置:12345678&quot;script&quot;:&#123; &quot;commit&quot;:&quot;git-cz&quot;&#125;,&quot;config&quot;:&#123; &quot;commitizen&quot;:&#123; &quot;path&quot;:&quot;node_modules/cz-conventional-changelog&quot; &#125;&#125; 4.3 自定义 Adapter也许 Angular 的那套规范我们不习惯, 那么可以通过指定 Adapter cz-customizable 指定一套符合自己团队的规范。我本人采用的就是使用最广泛的 Angular 规范，关于自定义规范，这里不再重复描述，具体请看这里。 参考 阮一峰：Commit message 和 Change log 编写指南 优雅的提交你的 Git Commit Message https://github.com/commitizen/cz-cli git commit 规范指南","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.yancongwen.com/tags/git/"}]},{"title":"原型与原型链","slug":"原型与原型链","date":"2018-09-18T08:09:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/09/18/原型与原型链/","link":"","permalink":"http://blog.yancongwen.com/2018/09/18/原型与原型链/","excerpt":"","text":"原型与原型链 大多数编程语言是基于类的语言，而 JS 是一种基于原型继承的语言。 1、为什么会有原型和原型链？&emsp;&emsp;首先，先来看一下为什么会有原型和原型链，原型和原型链能带来什么好处。在面向对象编程中，创建对象的的方式有很多种，最最简单的就是工厂模式和构造函数模式，然而，这些方式创建的对象，不能共享属性和方法，每一个对象会重复创建相同的属性和方法，造成内存资源的浪费。最简单的，每个变量都会有一个 toString 方法，那么是每个变量都有一个自己的方法吗，显然不是的。原型的作用就是帮助我们存放公用的属性和方法。 2、理解原型对象&emsp;&emsp;我们创建的每一个函数都有一个prototype属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，这个对象就是该函数的原型对象。原型对象自动获得一个constructor属性，这个属性又指向了函数本身。 3、理解原型链&emsp;&emsp;简单来讲，构造函数、原型、实例有如下关系：每一个构造函数都有一个原型对象prototypr，原型对象都包含一个指向构造函数的指针constructor，而实例都包含一个指向原型对象的内部指针__proto__。&emsp;&emsp;基于以上关系，我们让一个构造函数的原型等于另一个类型的实例，此时，该原型对象就包含了一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。加入另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是原型链的基本概念。 4、总结 1、 prototype是函数的原型对象，它是一个对象，这个对象又包含了一个constructor属性指向了该函数（prototype是函数的属性，而且我们一般讨论的是构造函数）； 2、 对象的__proto__指向它构造函数的prototype（__proto__是实例的属性）； 3、 所有的构造函数的原型链最后都会指向Object构造函数的原型，即可以理解Object构造函数的原型是所有原型链的最底层，即Object.prototype.__proto__===null； 4、 要寻找一个函数的prototype，就先看它是从谁继承来的； 5、 要寻找一个对象的__proto__，就先看它是谁的实例，找它的构造函数； 5、举例记住上一小节中的几句话，我们再来看下面的题目，就比较简单了。以下等式恒成立： 第一组: (几个原生对象的原型关系) 123456789Object.__proto__ === Function.prototype // 将Object视为Function的实例Object.prototype.__proto__ === null // 将Object视为构造函数Function.__proto__ === Function.prototype // 将Function视为Function的实例Function.prototype.__proto__ === Object.prototype //将Function视为构造函数，它的原型是Object的一个实例Array.__proto__ === Function.prototype // 将Array视为Function的实例Array.prototype.__proto__ === Object.prototype //将Array视为构造函数，它的原型是Object的一个实例//类推 Boolean、 String、 Number...... 第二组： 123456789101112131415var obj = &#123;&#125;obj.__proto__ === Object.prototype // obj是Object的实例obj.prototype === undefined // obj不是函数，所以没有原型对象属性var arr = []arr.__proto__ === Array.prototype // arr是Array的实例var fn = function()&#123;&#125;fn.__proto__ === Function.prototype // 将fn视为Function的实例fn.prototype.__proto__ === Object.prototype // 将fn视为函数，它的原型是Object的一个实例function Test()&#123;&#125;var test = new Test()Test.prototype.__proto__ === Object.prototype // 将Test视为构造函数，它的原型是Object的一个实例test.__proto__ === Test.prototype // test是Test的实例 参考 三句话给你解释清楚原型和原型链","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://blog.yancongwen.com/tags/Javascript/"}]},{"title":"JS数据类型转换","slug":"JS数据类型转换","date":"2018-09-18T08:07:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/09/18/JS数据类型转换/","link":"","permalink":"http://blog.yancongwen.com/2018/09/18/JS数据类型转换/","excerpt":"","text":"JS 数据类型转换任意类型转字符串 String(x) x.toString() x + ‘’ 任意类型转布尔 六个 falsy 值：false、0、NaN、null、undefined、&#39;&#39;(其实还有一个document.all)，除了以上六个值被转为false外，其他值都转为true； 所有的对象都被转换为 true（数组、函数、空数组、空对象） Boolean(x) !!x 任意类型转数字 Number(x) parseInt(x, 10) parseFloat(x) x - 0 +x","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://blog.yancongwen.com/tags/Javascript/"}]},{"title":"JS里的数据类型","slug":"JS里的数据类型","date":"2018-09-17T13:27:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/09/17/JS里的数据类型/","link":"","permalink":"http://blog.yancongwen.com/2018/09/17/JS里的数据类型/","excerpt":"","text":"JS中的数据类型七种：number、string、 boolean、 undefined、 null、 object、 symbol没有 array 噢 number 整数和小数：1、 1.1、 .1 科学记数法：1.23e2 二进制：0b11 八进制：011（后来 ES5 添加了 0o11 语法） 十六进制：0x11 string 空字符串： &#39;&#39; 多行字符串： 12 var s = `1234567890` // 含回车符号 Base64 Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法;Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。 编码方法：window.btoa(&quot;test&quot;)；//&quot;dGVzdA==&quot; 解码方法：window.atob(&quot;dGVzdA==&quot;);//&quot;test&quot; booleantrue or false undefined 和 null都可以表示“没有”，含义非常相似 （规范）如果一个变量没有被赋值，那么这个变量的值就是 undefiend （习俗）如果你想表示一个还没赋值的对象，就用 null。如果你想表示一个还没赋值的字符串/数字/布尔/symbol，就用 undefined（但是实际上你直接 var xxx 一下就行了，不用写 var xxx = undefined） null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN undefined == null //true object object 就是几种基本类型（无序地）组合在一起,可以无限嵌套 object 的 key 一律是字符串，不存在其他类型的 key（ES6中也可以是 Symbol类型的） object[&#39;&#39;] 是合法的 object[&#39;key&#39;] 可以写作 object.key object.key 与 object[key] 不同 delete object[&#39;key&#39;] &#39;key&#39; in object 用于判断是否存在这个 key symbolES6中新增的一个类型，它是 JavaScript 语言的第七种数据类型，表示独一无二的值。Symbol 值通过Symbol函数生成。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 typeof 操作符 类型 string number boolean symbol undefined null object function typeof的值 ‘string’ ‘number’ ‘boolean’ ‘symbol’ ‘undefined’ ‘object’ ‘object’ ‘function’ 1、注意 function 并不是一个类型;2、null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://blog.yancongwen.com/tags/Javascript/"}]},{"title":"在WSL中开发Node.js","slug":"在WSL中开发Node-js","date":"2018-08-28T09:19:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/08/28/在WSL中开发Node-js/","link":"","permalink":"http://blog.yancongwen.com/2018/08/28/在WSL中开发Node-js/","excerpt":"","text":"WSL 介绍 WSL(Windows Subsystem for Linux) 适用于Linux的Windows子系统，有了它，不要再安装臃肿的Vmware和VirtualBox等虚机机系统，就可以直接在Windows上体验原生的Linux应用了，甚至还有图形界面！ WSL是Win10提供的功能，默认关闭，需要去功能管理中开启WSL功能并重启计算机；然后在 Microsoft Store 中搜索 linux 或者 wsl ，会出现几个版本的linux系统供选择，直接安装想要的linux 发型版本即可。我这里安装的是 Ubuntu 18.04.1 LTS，大小约600MB，安装是一键安装的，安装完成直接点击图标即进入linux命令窗口。 WSL 安装的Linux子系统，拥有独立的目录系统，其目录在C盘中：C:\\Users\\username\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs 。虽然我们能找到这个目录，但是请不要在Windos中去操作这里的文件！ 个人理解，WSL安装的linux系统，其实仅仅是给了我们一个linux环境，其任然和Winddows系统共享计算机硬件，共享很多东西，比如磁盘、网络端口，linux中的localhost和windows中的localhost一致的。 基础环境安装安装的Ubuntu自带git、node，但是版本较低，需要升级。具体方法请自行百度。 git git 需要做一些简单的配置，想要以SSH方式连接远程仓库还要生成SSH Key并将公钥配置到远程仓库。这里要注意的是用户权限问题，在linux中不同用户创建的SSH Key并不相同。请看另一片文章。 node yarn npm 开发模式开始，我一直疑虑在WSL中应该以怎样的方式进行node开发。使用vim写代码对于我这种菜鸟还是太费力了，难道我还要在linux中再安装一下图形界面，然后再安装VSCode？不不不。还有一种方式，就是直接使用Windows中的VSCode打开Linux目录下的node项目，也就是直接打开上文提到的藏的很深的那个C盘目录下的项目，但是这种方式也很不优雅，一方面，我们使用window的编辑器去编辑改变linux中的文件，另一方面，我们要在linux中去执行node、yarn、git等命令，并且不能使用VScode去执行命令，不能使用VSCode去调试程序。 建立软连接如上文提及，我们使用VSCode去编辑Linux目录中项目，这个目录藏在C盘很深的位置，不仅占用C盘空间，还不方便管理，可以使用建立软连接的方式来解决。首选我们来看一下什么是软连接、硬连接： 软连接： 也叫符号连接（Symbolic Link），软链接文件类似于Windows的快捷方式，它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的文本就是连接的另一文件的位置。 硬连接： 硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 我们可以以建立软连接的方式，将F盘的开发目录连接到linux的目录下，这样既可以方便管理开发项目，也可以节省C盘空间占用。 Linux ln 命令创建连接 命令形式如下： ln (选项) [源文件] [文件连接]，创建软连接：ln -s \\mnt\\f\\wsl-dev \\home\\yancongwen\\develop 。以上命令就创建了一个软连接，将F盘的目录 wsl-dev 连接到了linux用户目录下的develop，这样我们就可以从linux中的develop访问F盘的开发目录，在linux中，develop目录就形同是一个文件夹，cd 命令可以进入访问。关于ln 命令的更多说明可以看这里。 这里也记录一下我踩过的坑： 1、ln 命令前一个参数是真实的数据存储所在，后一个参数是连接文件，不要搞反了；刚开始我就是在F盘创建的连接，而目录在linux目录下，显然是不合理的，也没什么用处； 2、源文件目录和连接文件都一定要采用绝对路径，不要采用~\\develop这样的相对路径；我一开始没注意到 ~\\就是相对路径，所以创建的连接文件一直进不去，把我郁闷坏了。 windows mklink 命令创建连接windows中同样支持创建软连接和硬连接，使用的是mklink命令。一开始我使用的就是mklink创建的软连接：mklink /D C:\\Users\\username\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\yancongwen\\develop F:\\wsl-dev （注意，这里前一个路径是连接，后一个连接是源文件），然而，才linux系统中，根本就识别不了这个连接，cd 命令进不去。所以不要使用windows的连接命令去连接linux目录。 【参考】 Win+Linux单系统解决方案——WSL（入门篇） 理解 Linux 的硬链接与软链接 linux 创建连接命令 ln -s 软链接","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.yancongwen.com/tags/linux/"}]},{"title":"Error: Permission denied (publickey)","slug":"Error-Permission-denied-publickey","date":"2018-08-23T11:37:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/08/23/Error-Permission-denied-publickey/","link":"","permalink":"http://blog.yancongwen.com/2018/08/23/Error-Permission-denied-publickey/","excerpt":"","text":"Git Error: Permission denied (publickey) 最近接触到一个nodejs后端服务项目，项目需要运行在linux环境中，经leader推荐，决定使用Win10的WSL功能，安装了Ubuntu 18.04。在Ubuntu中配置git中遇到了以下问题。 问题描述Ubuntu中自带了git，但是使用之前需要做一些配置。首先要做的事情就是设置你的名字和邮件地址，此外，使用ssh连接github或者gitlab这些远程仓库需要配置公钥。我按照如下命令生成了SSH Key，生成的密钥在 ~/.ssh 文件夹下，将公钥复制到github中即可。1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 然而，当我执行 sudo git clone git@gitlab.com:***.git 时，就失败了，显示如下信息: git@gitlab.com: Permission denied (publickey). fatal: Could not read from remote repository. 问题解决上面的信息显示应该是公钥出了问题。反复确认，我的公钥确实没有配置错误啊，而且执行ssh git@gitlab.com的时候确实显示SSH链接已经建立了呀。然而，当我执行sudo ssh git@gitlab.com的时候，同样抛出了Permission denied (publickey)，说明可能和sudo 有关。反反复复查资料，发现也有其他人出现了这个问题,但是按照里面的方法我并没有解决问题。最后，还是在github的帮助文档找到了问题所在。原来，在git命令前加上sudo权限后，使用的密匙就应该是 sudo权限下生成的 SSH Key，这个SSH Key 在\\root\\.ssh目录下，而我们配置的是~/.ssh 目录下的SSH Key。所以我所做的，就是使用sudo权限重新生成了SSH Key，然后将\\root\\.ssh目录下的公钥配置到github中，这样再执行sudo git这样的命令就OK了 参考 Generating a new SSH key and adding it to the ssh-agent Error: Permission denied (publickey)","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.yancongwen.com/tags/git/"},{"name":"linux","slug":"linux","permalink":"http://blog.yancongwen.com/tags/linux/"}]},{"title":"数据结构基础","slug":"数据结构基础","date":"2018-07-29T11:46:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/07/29/数据结构基础/","link":"","permalink":"http://blog.yancongwen.com/2018/07/29/数据结构基础/","excerpt":"","text":"哈希表（Hash Table） 计数排序中的桶（复杂度 O(n+max)，比快排还快 桶排序 与计数排序的区别 基数排序 与计数排序的区别 队列（Queue） 先进先出 可以用数组实现 举例：排队 栈（Stack） 先进后出 可以用数组实现 举例：盗梦空间 链表（Linked List） 数组无法直接删除中间的一项，链表可以 用哈希（JS里面用对象表示哈希）实现链表 head、node 概念 树（tree） 举例：层级结构、DOM 概念：层数、深度、节点个数 二叉树 满二叉树 完全二叉树 完全二叉树和满二叉树可以用数组实现 其他树可以用哈希（对象）实现 操作：增删改查 堆排序用到了 tree 其他：B树、红黑树、AVL树","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://blog.yancongwen.com/tags/计算机基础/"},{"name":"数据结构","slug":"数据结构","permalink":"http://blog.yancongwen.com/tags/数据结构/"}]},{"title":"CSS总结","slug":"CSS技巧","date":"2018-07-28T07:41:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/07/28/CSS技巧/","link":"","permalink":"http://blog.yancongwen.com/2018/07/28/CSS技巧/","excerpt":"","text":"本文记录一些CSS中的一些常识和技巧CSS 的学习不需要死记硬背，就是经验和熟练度，要会用工具。比如，要会搜索 “css generator” 一、知识点1、文档流 行内元素 块级元素 2、盒模型 padding border margin 3、定位 position static默认，没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 relative相对定位，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素原始位置留下空白） absolute绝对定位，相对于 static 定位以外的第一个父元素进行定位。 fixed固定定位，相对于浏览器窗口进行定位。 sticky粘性定位，基于用户滚动的位置，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。 二、技巧 调试技巧：给元素加border; 浮动，给父元素清除浮动; .clearfix{ content:’’; display:block; clear:both; } 不要上来就给div加高度和宽度，要让内容撑开它; div 的高度是由其文档流的高度决定的 height 和 width 是 bug 的来源 脱离文档流 三、常用工具网站 CSS技巧大全 CSS Tricks CSS 代码生成器 CSS3 Generator CSS 动画生成器 Animate.css 特殊符号大全 浏览器测试 BROWSERHACKS 获取渐变色 Ultimate CSS Gradient Generator 设计社区 dribbble","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.yancongwen.com/tags/CSS/"}]},{"title":"命令行技巧","slug":"命令行技巧","date":"2018-07-22T12:36:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/07/22/命令行技巧/","link":"","permalink":"http://blog.yancongwen.com/2018/07/22/命令行技巧/","excerpt":"","text":"技巧一：~/.bashrc自动运行1、首先 touch ~/.bashrc 创建一下这个文件2、start ~/.bashrc选用编辑器编辑这个文件，内容为 echo &#39;Hi&#39;3、你也可以用命令行编辑文件 echo &quot;echo &#39;hi&#39;&quot; &gt;&gt; ~/.bashrc4、关闭退出 Git Bash，然后打开 Git Bash，是不是看到了 Hi，这说明每次进入 Git Bash，就会优先运行 ~/.bashrc里面的命令5、重新编辑~/.bashrc，内容改为cd ~/Desktop，重启 Git Bash，有没有发现默认就进入桌面目录了？你可以用 ~/.bashrc 在进入 Git Bash 前执行任何命令，十分方便。 alias 别名1、 在 ~/.bashrc 里新增一行 alias f=&quot;echo &#39;frank is awesome&#39;&quot;，等于号两边不能有空格，你最好一个字都不要错。2、 运行 source ~/.bashrc，作用是执行 ~/.bashrc3、 运行 f，就会看到 frank is awesome4、 也就是说，现在 f 就是 echo &#39;frank is awesome&#39; 的缩写了，利用这个技巧，我们可以把很多常见的命令缩写一下，比如1234567alias la=&apos;ls -a&apos;alias ll=&apos;ls -l&apos;alias gst=&apos;git status -sb&apos;alias ga=&apos;git add&apos;alias ga.=&apos;git add .&apos;alias gc=&apos;git commit&apos;alias gc.=&apos;git commit .&apos; 保存退出，然后运行 source ~/.bashrc5、这样一来，你的 Git 操作就会简单很多：12345ga 1.txtga .gc 1.txtgc.gst","categories":[],"tags":[]},{"title":"Shadowsocks配置","slug":"shadowsocks","date":"2018-04-21T17:27:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/04/22/shadowsocks/","link":"","permalink":"http://blog.yancongwen.com/2018/04/22/shadowsocks/","excerpt":"","text":"记录一下Shadowsocks的配置过程 1. 通过SSH连接主机2. 安装Shadowsocks1234# apt-get update // 更新源中包列表# apt-get install python-pip // 安装pip# pip install --upgrade pip // 更新pip# pip install shadowsocks // 安装Shadowsocks 3. 配置Shadowsocks 编辑配置文件 1# vi /etc/shadowsocks.json 在文件中输入以下内容，保存 1234567891011&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_port&quot;:1080, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;port-password&quot;:&#123; // 设置端口号和对应的密码，自定义即可 &quot;9001&quot;:&quot;666666666&quot;, &quot;9002&quot;:&quot;666666666&quot; &#125;&#125; 配置完成以上内容，就可以运行ss了 1# ssserver -c /etc/shadowsocks.json -d start 4. 设置开机启动 编辑以下文件 1# vi /etc/rc.local 在文件中添加以下内容保存 1ssserver -c /etc/shadowsocks.json -d start","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.yancongwen.com/tags/工具/"}]},{"title":"Chorme插件推荐","slug":"chorme-plugs","date":"2018-04-21T03:49:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/04/21/chorme-plugs/","link":"","permalink":"http://blog.yancongwen.com/2018/04/21/chorme-plugs/","excerpt":"","text":"本文简单汇总下本人常用的 Chorme 插件，主要是 Web 前端开发中常用开发利器。 1. 日常使用 Proxy SwitchyOmega翻\\墙必备，控制代理模式，帮助我们合适高效翻\\墙,可以自定义翻\\墙规则 谷歌访问助手没有 VPN、Shadowsocks 等翻\\墙账号时可以暂时使用这个工具，但是只能满足部分需求，谷歌是可以的，youtube、twitter 这些就不行 Adblock Plus广告屏蔽插件 Google学术搜索查论文 CNKI E-Study配合 CNKI E-Study客户端使用，方便导入论文 OneTab当打开的标签页太多时，不仅自己不爽，还占电脑内存，此工具可以一键杀死谷歌浏览器中所有标签页，并将杀死的标签页保留，你可以随时恢复 Save to Pocket轻松保存文章、视频方便以后查看 有道词典Chrome划词插件网页鼠标划词翻译 Marinara番茄工作法助理 极简图床我目前使用的图床工具，配合七牛云使用，可以很方便地复制、拖拽、采集页面的图片到七牛云存储 新浪微博图床使用微博作为图床，本人之前使用的图床，偶尔会出现图片丢失的情况，现在已经全部转移到七牛云存储（配合极简图床） 2. Web 开发 Allow-Control-Allow-Origin: *该插件可谓是前端开发利器，帮助我们解决跨域问题。该插件实现跨域的机制是利用Chrome浏览器开发接口对请求头响应头做了修改。该插件在每次发起请求时，在请求头中添加了请求头 origin:http://evil.com/。详细信息可以参考这里 Vue.js devtoolsVue 开发必备 JSON ViewerJson 格式化工具 LiveReload配合 Sublime Text3 中 LiveReload 插件一起使用，修改代码后会自动刷新浏览器页面 Octotree在 GitHub 网页展示文件结构 Tampermonkey浏览器脚本管理工具，非常强大！其中有非常多开源脚本，脚本功能五花八门，只有你想不到的，没有它做不到，有兴趣可以试一下。 PostmanHTTP 请求工具，可以测试开发中后台接口 ng-inspect for AngularJSAngularJS 开发工具 AngularJS BatarangAngularJS 开发工具","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.yancongwen.com/tags/工具/"}]},{"title":"常见排序算法","slug":"算法初级","date":"2018-04-20T07:29:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/04/20/算法初级/","link":"","permalink":"http://blog.yancongwen.com/2018/04/20/算法初级/","excerpt":"","text":"排序是开发中十分常见且核心的操作，虽说实际项目中很小几率会需要我们手动实现，但是了解这些精妙的思想对我们还是大有裨益的。本文简单总结下最基础的几类算法。这里首先推荐一个数据结构和算法动态可视化网站：https://visualgo.net/zh 0. 概述 十种常见排序算法可以分为两大类： 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。 线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 算法复杂度 相关概念 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 1. 冒泡排序（Bubble Sort） 思想 对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。 在冒泡排序的过程中，如果某一趟执行完毕，没有做任何一次交换操作，比如数组[5,4,1,2,3]，执行了两次冒泡之后变为[1,2,3,4,5]。此时，再执行第三次循环后，一次交换都没有做，这就说明剩下的序列已经是有序的，排序提前完成。 算法分析 时间复杂度：Ο(n^2) 空间复杂度：Ο(1) JS实现 123456789101112131415161718192021222324function bubbleSort(arr) &#123; var len = arr.length; var i, j, temp, bSwap; for(i=0; i&lt;len-1; i++)&#123; bSwap = false; for(j=0; j&lt;len-i-1; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; bSwap = true; &#125; &#125; // 用于判断此轮循环有没有做交换，如果没有交换，说明数组已经是有序的了，排序完成 if (!bSwap)&#123; break; &#125; &#125; return arr;&#125;/* 交换两个数值的简便方式，接下来的代码就采用此方式： [a,b] = [b,a]; */ 2. 快速排序（Quick Sort） 思想 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 1、从数列中挑出一个元素，称为 “基准”； 2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置，这个称为分区操作； 3、对每个分区不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 3. 插入排序4. 希尔排序5. 选择排序6. 归并排序7. 堆排序8. 计数排序（Count Sort） 简介 计数排序不是基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，快于任何比较排序算法。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 思想 1、找出待排序的数组中最大和最小的元素； 2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 算法分析 时间复杂度：Ο(n+k)，k为待排序数的范围，n为数组长度 空间复杂度：Ο(k) 稳定性：稳定 要求：数值较小的整数数组。计数排序是一种以空间换时间的排序算法，并且只适用于待排序列中所有的数较为集中时。当数组较为分散时，比如一组序列中的数据为0 1 2 3 4 999就得开辟1000个辅助空间，就很不划算。 JS实现 1234567891011121314151617181920212223242526272829function countingSort(arr)&#123; var len = arr.length, Result = [], Count = [], min = max = arr[0]; console.time('countingSort waste time:'); /*查找最大最小值,并将arr数置入Count数组中,统计出现次数*/ for(var i = 0;i&lt;len;i++)&#123; Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; min = min &lt;= arr[i] ? min : arr[i]; max = max &gt;= arr[i] ? max : arr[i]; &#125; console.log(Count) /*从最小值-&gt;最大值,将计数逐项相加*/ for(var j = min;j&lt;max;j++)&#123; Count[j+1] = (Count[j+1]||0)+(Count[j]||0); &#125; /*Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据*/ for(var k = len - 1;k&gt;=0;k--)&#123; /*Result[位置] = arr数据*/ Result[Count[arr[k]] - 1] = arr[k]; /*减少Count数组中保存的计数*/ Count[arr[k]]--; /*显示Result数组每一步详情*/ console.log(Result); &#125; console.timeEnd(\"countingSort waste time:\"); return Result;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.yancongwen.com/categories/技术/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://blog.yancongwen.com/tags/计算机基础/"},{"name":"算法","slug":"算法","permalink":"http://blog.yancongwen.com/tags/算法/"}]},{"title":"Centering in CSS","slug":"css-centering","date":"2018-04-18T17:29:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/04/19/css-centering/","link":"","permalink":"http://blog.yancongwen.com/2018/04/19/css-centering/","excerpt":"","text":"本文翻译自 CSS-Tricks 中的一篇文章—— Centering in CSS: A Complete Guide，CSS居中完全指南，其中有部分删改。 &emsp;&emsp;Centering things in CSS is the poster child of CSS complaining. Why does it have to be so hard? They jeer. I think the issue isn’t that it’s difficult to do, but in that there so many different ways of doing it, depending on the situation, it’s hard to know which to reach for.&emsp;&emsp;居中是一种很常见的布局方式。有人抱怨CSS居中布局很难，其实不然，在我看来，说居中布局难，不是因为居中真的有多么难实现，而是因为实现居中的方法有太多太多，以至于新手总是纠结去用哪个。我们需要根据不同的场景，去选择合适的方法。&emsp;&emsp;本文将CSS居中布局方法进行归类，以便于理解和简化居中问题。 1.水平居中1.1 行内元素行内元素直接为其父元素设置文本居中即可。123.center-children &#123; text-align: center;&#125; https://codepen.io/chriscoyier/pen/HulzB 1.2 块级元素块级元素直接设置左右边距为 auto 即可，前提是该块级元素必需有 width ，而且必需处于标准文档流中，浮动、绝对定位、固定定位了的元素就不能。 123.center-me &#123; margin: 0 auto;&#125; https://codepen.io/chriscoyier/pen/eszon 1.3 多个块级元素 多个块元素在一行内居中 方法一：父元素设置 text-align: center ，子元素设置 display: inline-block； 方法二：使用 flex 布局，父元素设置 display: flex; justify-content: center; 多个块元素在一列内居中如果只是需要让多个块级元素整体水平居中，并且按默认的方式纵向排列，那直接设置左右边距为 auto 即可。 2. 垂直居中2.1 行内元素 单行居中 设置行高与元素的高度相同https://codepen.io/chriscoyier/pen/LxHmK 为行内元素/文本元素设置相等的上下内边距https://codepen.io/chriscoyier/pen/ldcwq 多行居中 设置相等的上下内边距 vertical-align 属性来实现垂直居中 https://codepen.io/chriscoyier/pen/ekoFx flexboxhttps://codepen.io/chriscoyier/pen/uHygv123456.flex-center-vertically &#123; display: flex; justify-content: center; flex-direction: column; height: 400px;&#125; 2.2 块级元素 元素高度已知 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; /* account for padding and border if not using box-sizing: border-box; */&#125; https://codepen.io/chriscoyier/pen/HiydJ 元素高度未知（最常见的一种场景） 方法一：先将元素相对于其原始位置向下移动父元素高度的一半距离，再将该元素相对其本身的高度向上移动一半，这样就能实现垂直居中的效果了。 12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; https://codepen.io/chriscoyier/pen/lpema 方法二：flexbox 12345.parent &#123; display: flex; flex-direction: column; justify-content: center;&#125; https://codepen.io/chriscoyier/pen/FqDyi 3. 垂直和水平都居中当然，我们可以结合以上给出的方法来实现垂直和水平方向都居中的布局。这里我们再进行一下分类总结。 3.1 宽高固定将元素相对于其父元素的宽度/高度值向右并向下移动一半的距离，然后再通过设置负边距值的方法，将元素相对于其自身的宽度/高度值向左并向上移动一半的距离，就可实现水平垂直均居中的效果了。并且这种方法的浏览器兼容性是很好的。123456789101112131415.parent &#123; position: relative;&#125;.child &#123; width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px;&#125; https://codepen.io/chriscoyier/pen/JGofm 3.2 宽高不固定如果元素的宽度或者高度未知，则在将元素相对于父元素的宽高往向右并向下移动一半距离后，再用 transform 属性来将其向左并向上移动自身宽度及高度值一半的距离即可。123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; https://codepen.io/chriscoyier/pen/lgFiq 3.3 使用 flexbox12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; https://codepen.io/chriscoyier/pen/msItD 3.4 使用 grid这只是一个小技巧，只适用于一个元素的情况。 4. 结束语CSS 还是很伟大的，能够实现的布局多种多样，实现的方法也多种多样，重要的是找到合适的方法！这就需要多写多练多总结！","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.yancongwen.com/categories/技术/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.yancongwen.com/tags/CSS/"},{"name":"译文","slug":"译文","permalink":"http://blog.yancongwen.com/tags/译文/"}]},{"title":"Git基础","slug":"Git基础","date":"2018-04-15T13:37:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/04/15/Git基础/","link":"","permalink":"http://blog.yancongwen.com/2018/04/15/Git基础/","excerpt":"","text":"1、工作区、暂存区、版本库、远程库 工作区（Working Directory） 就是你在电脑里能看到的目录 版本库（Repository） 工作区有一个隐藏目录.git就是版本库。 暂存区 Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 maste r的一个指针叫HEAD。 远程库 指 github 或码云等 git 服务器上的版本库，也可以自己搭建 git 服务器。 2、常用命令 git init：初始化一个Git仓库 git add：把文件修改添加到暂存区，可反复多次使用，添加多个文件 git add -A // 添加所有改动 git add * //加新建文件和修改，但是不包括删除 git add . //加新建文件和修改，但是不包括删除 git add -u //加修改和删除，但是不包括新建文件 git commit：提交更改，把暂存区的所有内容提交到当前分支 git status：查看仓库当前的状态 -s：以简洁的形式显示 -b：也显示分支的状态 git diff：查看改变 git log：查看提交历史 git reflog：查看命令历史 –pretty=oneline 一行显示 git reset：回退到指定版本。HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id git clone :克隆远程库 12345678910// SSH加密git clone git@github.com:yancongwen/仓库名.git// HTTPS加密，采用此协议的话以后每次推送都要登陆，比较繁琐git clone https://github.com/yancongwen/仓库名.git// 克隆分支: git clone -b &lt;branch name&gt; [remote repository address].git// 或者：git clone &lt;respository-name&gt;,先克隆库git checkout &lt;branchname&gt;,检出分支git pull 取回远程主机某个分支的更新，再与本地的指定分支合并 git pull: 取回远程主机某个分支的更新，再与本地的指定分支合并 1234$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;// 例：$ git pull origin next:master // 取回origin主机的next分支，与本地的master分支合并 git push：将本地分支的更新，推送到远程主机 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 3、命令","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.yancongwen.com/tags/git/"}]},{"title":"HTTP总结（前端开发中的常识性问题）","slug":"HTTP总结--前端开发中的常识性问题","date":"2018-04-11T05:33:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2018/04/11/HTTP总结--前端开发中的常识性问题/","link":"","permalink":"http://blog.yancongwen.com/2018/04/11/HTTP总结--前端开发中的常识性问题/","excerpt":"","text":"1. TCP/IP 简介 首先应该理解 TCP/IP 协议族中的四个分层：应用层、传输层、网络层、数据链路层，详细请看另一篇博客。 HTTP 位于应用层，负责生成或解析报文 TCP、UDP 位于传输层，负责将报文方便、可靠得传输 IP 位于网络层，负责搜索地址、路由中转、传输 数据链路层是硬件设备 2. HTTP HyperText Transfer Protocol，超文本转移协议，是TCP/IP 协议族的子集，用于客户端和 服务器之间的通信。详细请看其他文章：HTTP基础、HTTP报文、HTTP状态码、HTTP首部。 请求报文 响应报文 Chrome开发者工具查看 HTTP 报文 ① 打开 Network ② 地址栏输入网址 ③ 在 Network 点击，查看 Request/Response Headers，点击「view source」 3. TCP、UDP TCP（三次握手，四次挥手） 可靠：三次握手、四次挥手； 字节流服务：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理； 可靠、面向连接、相对 UDP 较慢； UDP 不可靠，不面向连接、相对 TCP 较快 4. curl 命令的使用 在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。 语法： 1# curl [option] [url] 常见参数 -s ：silent，安静模式，不显示过程或错误信息 -v ：verbose，显示请求和响应报文 -I ：head，仅仅显示响应报文，不显示请求返回的内容 -i ：include，显示响应报文 -H ：header，增加请求时的请求头信息 -X ：request，自定义请求方法，默认为GET -d ：data，定义POST请求中发送的数据 -A ：agent，自定义User-Agent用户代理 -o : output，保存到指定文件 示例 123456789101112131415// 最简单用法，显示请求过程和请求结果$ curl www.baidu.com // 最常用用法，显示请求报文、响应报文、请求结果$ curl -s -v www.baidu.com // 自定义用POST方法进行HTTP通信，并添加自定义请求头$ curl -X POST -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot; // 发送数据$ curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot; // 下载文件保存到本地指定文件$ curl http://www.baidu.com &gt; index.html$ curl -o index.html http://www.baidu.com","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"命令行基础","slug":"命令行基础","date":"2018-03-30T17:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/03/31/命令行基础/","link":"","permalink":"http://blog.yancongwen.com/2018/03/31/命令行基础/","excerpt":"","text":"首先，推荐一个网站explainshell.com，超级强大的Linux命令解释工具，在搜索框里任意输入Linux命令，系统会将命令解析。 1.常用单词及缩写 英文 翻译 directory 目录、文件夹 file 文件 make 新建 remove 删除 move 移动 copy 复制 list 罗列 link 链接 find 查找 echo 发出回音、重复 touch 触摸 change 改变 缩写 命令 全写 缩写 创建目录 make directory mkdir 删除 remove rm 移动 / 重命名 move mv 复制 copy cp 罗列 list ls 改变目录 change directory cd 2.常见的自带命令 操作 命令 进入目录 cd 显示当前目录 pwd 创建目录 mkdir 目录名 创建目录 mkdir -p 目录路径 显示用户名 whoami 查看路径 ls 路径 查看路径 ls -a 路径 查看路径 ls -l 路径 查看路径 ls -al 路径 创建文件 echo ‘1’ &gt; 文件路径 强制创建文件 echo ‘1’ &gt;! 文件路径 追加文件内容 echo ‘1’ &gt;&gt; 文件路径 创建文件 touch 文件名 改变文件更新时间 touch 文件名 复制文件 cp 源路径 目标路径 复制目录 cp -r 源路径 目标路径 移动节点 mv 源路径 目标路径 删除文件 rm 文件路径 强制删除文件 rm -f 文件路径 删除目录 rm -r 目录路径 强制删除目录 rm -rf 目录路径 查看目录结构 tree 建立软链接 ln -s 真实文件 链接 下载文件 curl -L https://www.baidu.com &gt; baidu.html 拷贝网页 wget -p -H -e robots=off https://www.baidu.com 磁盘占用 df -kh 当前目录大小 du -sh 各文件大小 du -h 显示当前用户 whoami 显示命令路径 where name 查找命令路径 which name","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://blog.yancongwen.com/tags/计算机基础/"}]},{"title":"图解HTTP学习笔记(七)：HTTPS","slug":"图解HTTP学习笔记七--HTTPS","date":"2018-01-12T12:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/01/12/图解HTTP学习笔记七--HTTPS/","link":"","permalink":"http://blog.yancongwen.com/2018/01/12/图解HTTP学习笔记七--HTTPS/","excerpt":"","text":"1. HTTP 的缺点 通信使用明文（不加密），内容可能会被窃听； 不验证通信方的身份，因此有可能遭遇伪装（ DoS 攻击，拒绝服务攻击）； 无法证明报文的完整性，所以有可能已遭篡改（中间人攻击，MITM）； 2. HTTPS 是身披 SSL 外壳的 HTTP HTTPS = HTTP + 加密 + 认证 + 完整性保护 &emsp;&emsp;HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。&emsp;&emsp;SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是 当今世界上应用最为广泛的网络安全技术。 3. 相互交换密钥的公开密钥加密技术 共享密钥加密 使用两把密钥的公开密钥加密 HTTPS 采用混合加密机制 4. 证明公开密钥正确性的证书&emsp;&emsp;遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。 5. HTTPS 的安全通信机制 6. HTTPS 缺点 消耗更多 CPU 及内存等资源，导致处理速度变慢； 和HTTP相比，SSL 通信使通信量会增加； HTTPS 比 HTTP 要慢 2 到 100 倍； 证书必须向认证机构（CA）购买；","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"图解HTTP学习笔记(六)：HTTP首部","slug":"图解HTTP学习笔记六--HTTP首部","date":"2018-01-12T10:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/01/12/图解HTTP学习笔记六--HTTP首部/","link":"","permalink":"http://blog.yancongwen.com/2018/01/12/图解HTTP学习笔记六--HTTP首部/","excerpt":"","text":"HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。报文结构： 一、首部字段HTTP/1.1 规范定义了 47 种首部字段。HTTP 首部字段根据实际用途被分为以下 4 种类型： 通用首部字段：请求报文和响应报文双方都会使用的首部 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Program 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段：请求报文中，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等。 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在的服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与If-Match相反） If-Range 资源未更新时发送实体Byte的范围请求 If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中的URI的原始获取方 TE 传输编码的优先级 User-Agent HTTP客户端程序的信息 响应首部字段：响应报文中， 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 Content-Disposition 可以控制返回的资源是下载还是预览（图片） ETag 资源的匹配信息 Location 令客户端重定向至指定URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段：包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体使用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替换对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 二、通用首部字段 1、Cache-Control请求指令：响应指令： 2、Connection 控制不再转发给代理的首部字段 管理持久连接 HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。 HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。 3、Data 4、Pragma 5、Trailer 6、Transfer-Encoding 7、Upgrade 8、Via 报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。 9、Warning 该首部通常会告知用户一些与缓存相关的问题的警告 三、请求首部字段 1、Accept Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。 2、Accept-Charset 用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。 3、Accept-Encoding 用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序 4、Accept-Language 告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。 5、Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。 6、Expect 告知服务器，期望出现的某种特定行为 7、From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的 电子邮件联系方式。 8、Host 告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。 9、If-Match 形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求 只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求 10、If-None-Match 只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求 11、If-Modified-Since 如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求 12、If-Unmodified-Since 如果在 If-Unmodified-Since 字段指定的日期时间后，资源没有发生更新，服务器才会接受请求 13、If-Range 它告知服务器若指定的 IfRange 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。反之，则返回全体资源。 14、Max-Forwards 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的 值减 1 后重新赋值。当服务器接收到Max-Forwards 值为 0 的请求 时，则不再进行转发，而是直接返回响应。 15、Proxy-Authorization 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。 16、Range 可告知服务器资源的指定范围。接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。 17、Referer 告知服务器请求的原始资源的 URI Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。 18、TE 告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。 19、User-Agent 将创建请求的浏览器和用户代理名称等信息传达给服务器。 四、响应首部字段 1、Accept-Ranges 用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。 2、Age 告知客户端，源服务器在多久前创建了响应 3、ETag 告知客户端实体标识。例如，当使用中文版的浏览器访问 http://www.google.com/ 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的 URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下 载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。 4、Location 将响应接收方引导至某个与请求 URI 位置不同的资源。基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。 5、Proxy-Authenticate 把由代理服务器所要求的认证信息发送给客户端。 6、Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。 7、Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息 8、Vary 可对缓存进行控制。 9、WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。 五、实体首部字段 1、Allow 用于通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。 2、Content-Encoding 告知客户端服务器对实体的主体部分选 用的内容编码方式。 主要采用以下 4 种内容编码的方式: gzip、compress、deflate、identity 3、Content-Language 实体主体使用的自然语言 4、Content-Length 实体主体部分的大小。 5、Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。 6、Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，&gt; 以及确认传输到达 7、Content-Range 针对范围请求，告知客户端作为响应返回的实体的哪个部分符合范围请求 8、Content-Type 了实体主体内对象的媒体类型 9、Expires 将资源失效的日期告知客户端 10、Last-Modified 资源最终修改的时间 六、为 Cookie 服务的首部字段 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的Cookie信息 响应首部字段 Cookie 服务器接收到的Cookie信息 请求首部字段 1、Set-Cookie 属性表： 属性 说明 NAME=VALUE 赋予Cookie的名称和其值（必需项） expires=DATE Cookie的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名） Secure 仅在HTTPS完全通信时才会发送Cookie HttpOnly 加以限制，使Cookie不能被JavaScript脚本访问 2、Cookie 告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。 七、其他首部字段HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。如： 1、X-Frame-Options 2、X-XSS-Protection 3、DNT 4、P3P","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"图解HTTP学习笔记(五)：HTTP状态码","slug":"图解HTTP学习笔记五--HTTP状态码","date":"2018-01-11T01:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/01/11/图解HTTP学习笔记五--HTTP状态码/","link":"","permalink":"http://blog.yancongwen.com/2018/01/11/图解HTTP学习笔记五--HTTP状态码/","excerpt":"","text":"HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。 状态码 类别 原因短语 1XX Informational(信息性状态码) 接受的请求正在处理 2XX Success(成功) 请求正常处理 3XX Redirecton(重定向) 需要进行附加操作 4XX Client Error(客户端错误) 服务器无法完成请求 5XX Server Error(服务端错误) 服务器处理请求出错 1. 2XX 成功 200 OK 请求在服务器端被正常处理 204 No Content 返回的响应报文中不含实体的主体部分 206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 2. 3XX 重定向 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。 和 301 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。 303 See Other 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 304 Not Modified 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。 307 Temporary Redirect 临时重定向。该状态码与 302 Found 有着相同的含义。 3. 4XX 客户端错误 400 Bad Request 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。 401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证的认证信息。若之前已进行过 1 次请求，则表示认证失败。 403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要 给出拒绝的详细理由。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。 404 Not Found 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 4. 5XX 服务器错误 500 Internal Server Error 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。 503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法 处理请求。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"图解HTTP学习笔记(四)：HTTP报文","slug":"图解HTTP学习笔记四--HTTP报文","date":"2018-01-10T01:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/01/10/图解HTTP学习笔记四--HTTP报文/","link":"","permalink":"http://blog.yancongwen.com/2018/01/10/图解HTTP学习笔记四--HTTP报文/","excerpt":"","text":"&emsp;&emsp;用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。&emsp;&emsp;HTTP 报文大致可分为报文首部和报文主体两块。 HTTP报文结构： HTTP报文实例：","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"图解HTTP学习笔记(三)：HTTP基础","slug":"图解HTTP学习笔记三--HTTP基础","date":"2018-01-09T14:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/01/09/图解HTTP学习笔记三--HTTP基础/","link":"","permalink":"http://blog.yancongwen.com/2018/01/09/图解HTTP学习笔记三--HTTP基础/","excerpt":"","text":"HTTP，即 超文本传输协议 (HyperText Transfer Protocol)。 1. HTTP 方法 下面列出HTTP1.1中的请求方法： 方法 说明 GET 获取资源 POST 传输数据实体 PUT 传输文件 HEAD 获取报文首部 DELETE 删除文件 OPTIONS 询问支持的方法 TARACK 追踪路径 CONNECT 要求用隧道协议连接代理 2. 持久连接&emsp;&emsp;持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并 未标准化。 3. 管线化&emsp;&emsp;持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。 4. 使用 Cookie 的状态管理&emsp;&emsp;HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。&emsp;&emsp;Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"图解HTTP学习笔记(二)：URI和URL","slug":"图解HTTP学习笔记二--URI和URL","date":"2018-01-08T14:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/01/08/图解HTTP学习笔记二--URI和URL/","link":"","permalink":"http://blog.yancongwen.com/2018/01/08/图解HTTP学习笔记二--URI和URL/","excerpt":"","text":"1. 统一资源标识符 URI1.1 统一资源标识符 URI (Uniform Resource Identifier)URI 就是标识某一互联网资源的字符串。URI可被视为定位符（URL），名称（URN）或两者兼备。 1.2 统一资源定位符 URL (Universal Resource Locator)URL是URI的最常见形式，它标识一个互联网资源，也被称为 Web 地址。 URL 是 URI 的子集。例如： 12345https://developer.mozilla.orghttps://developer.mozilla.org/en-US/docs/Learn/https://developer.mozilla.org/en-US/search?q=URLftp://ftp.is.co.za/rfc/rfc1808.txtmailto:John.Doe@example.com 1.3 统一资源名称 URN (Universal Resource Name)通过特定命名空间中的唯一名称来标识资源。例如： 12345urn:isbn:9780141036144urn:ietf:rfc:7230上面两个 URN 分别标识了下面的资源： - 乔治·奥威尔所著的《1984》 - IETF规范7230，超文本传输协议 (HTTP/1.1)：Message Syntax and Routing. 1.4 三者关系RL和URN都是URI的子集。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。在 知乎 上有人这么回答：原来URI包括URL和URN，后来URN没流行起来，导致几乎目前所有的URI都是URL。 2. URI 格式 方案或协议：http:// 告诉浏览器使用何种协议，对于大部分 Web 资源，通常使用 HTTP 协议或其安全版本，HTTPS 协议。还有：ftp、data、file、mailto、tel等协议。 服务器地址： IPv4、IPV6地址或域名。 端口号：若使用默认端口号可以省略，默认端口（HTTP为80，HTTPS为443）。 路径：资源的路径。 查询字符串：是提供给 Web 服务器的额外参数，这些参数是用 &amp; 符号分隔的键/值对列表。 片段标识符：是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。 参考： Mozilla中统一资源标识符的语法 URL和URI的区别","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"图解HTTP学习笔记(一)：网络基础","slug":"图解HTTP学习笔记一--网络基础","date":"2018-01-08T01:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2018/01/08/图解HTTP学习笔记一--网络基础/","link":"","permalink":"http://blog.yancongwen.com/2018/01/08/图解HTTP学习笔记一--网络基础/","excerpt":"","text":"计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议(Protocol)。 1. TCP/IP 协议族 TCP/IP 是互联网相关的各类协议族的总称也有说法 认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/ IP 是在 IP 协议的通信过程中，使用到的协议族的统称。 2. TCP/IP 的分层管理TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层： 应用层 应用层决定了向用户提供应用服务时通信的活动。 包括：FTP、DNS、HTTP 传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 包括：TCP、UDP 网络层 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 包括：IP、 数据链路层 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内。 3. TCP/IP 通信传输流 &emsp;&emsp;用 HTTP 举例来说明： 首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。 这样一来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。 4. 与 HTTP 关系密切的协议 : IP、TCP 和 DNS4.1 负责传输的 IP 协议&emsp;&emsp;按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能 有人会把“IP”和“IP 地址”搞混，“IP”是协议的名称。&emsp;&emsp;IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变，但 MAC 地址基本不会。&emsp;&emsp;IP 间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。&emsp;&emsp;在到达通信目标前的中转过程中，那些计算机和路由器等网设备只能获悉很粗略的传输路线。这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中。 4.2 确保可靠性的 TCP 协议&emsp;&emsp;按层次分，TCP 位于传输层，提供可靠的字节流服务。&emsp;&emsp;字节流服务：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。&emsp;&emsp;可靠：TCP 协议能够确认数据最终是否送达到对方。为了准确无误地将数据送达目标处，TCP 协议建立连接时采用三次握手 （three-way handshaking）策略。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，完成三次握手，客户端与服务器开始传送数据。&emsp;&emsp;数据传输完成后，采用四次挥手策略关闭TCP连接。第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。 4.3 负责域名解析的 DNS 服务&emsp;&emsp;DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。 5. 各种协议与 HTTP 协议的关系","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.yancongwen.com/tags/计算机网络/"}]},{"title":"CSS-Sticky-Footer","slug":"CSS-Sticky-Footer","date":"2017-07-28T11:21:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2017/07/28/CSS-Sticky-Footer/","link":"","permalink":"http://blog.yancongwen.com/2017/07/28/CSS-Sticky-Footer/","excerpt":"","text":"什么是 Sticky Footer&emsp;&emsp;Sticky Footer 即绝对底部。具体效果就是：当页面内容超出屏幕，页脚模块会像正常页面一样，被推到内容下方，需要拖动滚动条才能看到。而当页面内容小于屏幕高度，页脚模块会固定在屏幕底部，就像是底边距为零的固定定位。 常见解决方法 经典思路 HTML： 12345678&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; &lt;p&gt;页脚&lt;/p&gt;&lt;/div&gt; CSS： 12345678910111213141516html,body &#123; height: 100%;&#125;body &gt; .wrap &#123; min-height: 100%;&#125;.content &#123; /* padding-bottom 等于 footer 的高度 */ padding-bottom: 60px;&#125;.footer &#123; width: 100%; height: 60px; /* margin-top 为 footer 高度的负值 */ margin-top: -60px;&#125; Flexbox解决方案 HTML： 123456&lt;div class=&quot;content&quot;&gt; &lt;p&gt;内容&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; &lt;p&gt;页脚&lt;/p&gt;&lt;/div&gt; CSS： 12345678html, body &#123; display: flex; height: 100%; flex-direction: column;&#125;body .content &#123; flex: 1;&#125; 固定高度的解决方案(不推荐) HTML： 1234&lt;body&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; CSS： 1234.content&#123; min-height:calc(100vh-footer的高度); box-sizing:border-box;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.yancongwen.com/tags/CSS/"}]},{"title":"CSS定位","slug":"CSS定位-1","date":"2017-07-28T11:15:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2017/07/28/CSS定位-1/","link":"","permalink":"http://blog.yancongwen.com/2017/07/28/CSS定位-1/","excerpt":"","text":"CSS定位1. 默认值 （static） 没有定位，元素出现在正常的流中 会忽略 top, bottom, left, right 或者 z-index 声明 2. 相对定位（relative） 相对定位，就是微调元素位置的。让元素相对自己原来的位置，进行位置调整 相对定位不脱标，真实位置是在老家，只不过影子出去了，可以到处飘 使用场景： 微调元素 做绝对定位的参考，子绝父相 3. 绝对定位 （absolute） 绝对定位比相对定位更灵活 脱离标准文档流，所有标准文档流的性质，绝对定位之后都不遵守了（绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要 display:block; 就可以设置宽、高了） 参考点 绝对定位的参考点，如果用top描述，那么定位参考点就是页面的左上角，而不是浏览器的左上角 如果用bottom描述，那么就是浏览器首屏窗口尺寸，对应的页面的左下角 以盒子为参考点 一个绝对定位的元素，如果父辈元素中出现了也定位了的元素(static除外)，那么将以父辈这个元素，为参考点。 要听最近的已经定位的祖先元素的，不一定是父亲，可能是爷爷。 不一定是相对定位，任何定位，都可以作为参考点。子绝父绝、子绝父相、子绝父固，都是可以给儿子定位的。但是，工程上子绝父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。工程上，“子绝父相”才有意义，父亲没有脱标，儿子脱标在父亲的范围里面移动。 绝对定位的儿子，无视参考的那个盒子的padding。 绝对定位的盒子居中问题 绝对定位之后，所有标准文档流的规则，都不适用了。所以margin:0 auto; 失效。可使用以下方式使之居中。 12left: 50%;margin-left: 负的盒子宽度的一半。 4. 固定定位 （fixed） 固定定位，就是相对浏览器窗口定位。无论页面如何滚动，这个盒子显示的位置都不变。 脱标 5. 粘性定位 （sticky） 基于用户滚动的位置定位 它的行为就像 position:relative;，而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置 目前还是实验属性 常见的一种使用场景是绝对底部（Sticky Footer）","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.yancongwen.com/tags/CSS/"}]},{"title":"Hexo搭建博客","slug":"Hexo搭建博客-2","date":"2017-07-16T03:39:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2017/07/16/Hexo搭建博客-2/","link":"","permalink":"http://blog.yancongwen.com/2017/07/16/Hexo搭建博客-2/","excerpt":"","text":"本文主要记录一下本人使用 hexo + github 搭建个人博客的流程及hexo使用技巧和相关辅助工具。 1.Hexo搭建博客1.1 Hexo介绍Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，可利用靓丽的主题生成静态网页。Hexo可以托管到github等代码托管平台上，开启page功能就可以访问。 1.2 第一篇博客 安装hexo 1$ npm install -g hexo-cli 新建项目 123$ mkdir filename &amp;&amp; cd filename // 创建并进入一个目录$ hexo init // 初始化$ hexo install // 安装依赖包 生成页面 1$ hexo generate 部署 1$ hexo server 第一篇博客就搭建完成了。访问http://localhost:4000 就可看到你的博客 1.3 github部署将生成的博客页面部署到github上就可以让别人访问了。 新建github仓库，仓库名要和用户名一样 修改配置文件_config.yml,如下，设置github仓库的ssh地址（可以同时部署到码云gitee等其他平台上） 123456deploy: type: git repo: github: git@github.com:username/username.github.io.git gitee: git@gitee.com:username/username.git branch: master 访问 http://username.github.io.就是你的博客了 还可以设置自定义域名 1.4 主题设置hexo提供了很多主题，更换主题也比较简单 第一步，克隆主题到本地 themes目录下 第二步，修改配置文件_config.yml下的them项就好了 1.5 使用流程hexo写博客的一般流程是下面这样的：1234hexo new title // 新建文章 hexo g // 文章写好之后生成页面hexo s // 开启本地服务器来预览页面hexo d // 部署 2 开启HTTPS近年来Google一直在力推HTTPS加密协议，替换HTTP协议，Chrome浏览器68版本更是直接将所有的HTTP页面都标上“不安全”标签。虽然个人博客不会涉及账号密码登录泄露等问题，但为了获取浏览器的信任，开启HTTPS还是很有必要的。HTTPS协议要求整个页面所引用的和加载的资源必须也为HTTPS协议方可。 Github开启HTTPS直接在博客仓库下的设置项中找到 Enforce HTTPS选项打钩即可 申请免费SSL证书如果绑定了个人域名，需要申请SSL证书。腾讯云里可以申请免费的证书。 七牛云开启HTTPS七牛云用于存储博客的图片、视频等资源。将申请的SSL证书导入七牛云，然后开启HTTPS服务。 3 Hexo-admin管理博客hexo-admin是一款帮助我们管理文章的插件，比较实用。如下所示，只要我们跑起来server，就可以访问http://localhost:4000/admin/了，这个页面就是我们管理文章的页面了。不过deploy部署命令有点问题。123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/ 4 多终端使用有时候可能想在不同的电脑写文章，所以我们需要将博客的生成代码做一下备份。「你的用户名.github.io」上保存的只是你的博客，并没有保存「生成博客的程序代码」，你需要再创建一个名为 blog-generator 的空仓库，用来保存「生成博客的程序代码」。以后每次 hexo deploy 完之后，博客就会更新；然后你还要要 add / commit /push 一下「生成博客的程序代码」，将源文件也更新一下。这样你在另一台电脑上就可以clone这份源码，同时部署相同的环境（node、git、hexo、hexo-admin），就可以写代码了。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.yancongwen.com/tags/工具/"}]},{"title":"HTML标签","slug":"HTML标签","date":"2017-04-13T11:46:00.000Z","updated":"2019-03-28T06:16:34.335Z","comments":true,"path":"2017/04/13/HTML标签/","link":"","permalink":"http://blog.yancongwen.com/2017/04/13/HTML标签/","excerpt":"","text":"1、iframe 标签iframe 元素会创建包含另外一个文档的内联框架,相当于是一个独立的新窗口； src 属性，窗口对应的链接地址，支持相对路径； frameborder 属性，一般会设置 frameborder=0，表示没有边框； name 属性，框架名称，一般配合 a 标签使用；12&lt;iframe name=\"xxx\" src=\"http://www.baidu.com\" frameborder=\"0\"&gt;&lt;/iframe&gt;&lt;a href=\"http://www.qq.com\" target=\"xxx\"&gt;在iframe中打开QQ页面&lt;/a&gt; 2、a 标签定义超链接 href 属性 ，指示链接的目标 常规：href=&quot;http://www.qq.com&quot; 省略协议，就会使用当前协议：href=&quot;www.qq.com&quot; 相对路径：href=&quot;/index.html&quot; 空值：href=&quot;&quot;(会请求当前页面，极少使用) 查询参数：href=&quot;?name=xxx&quot;（会触发请求） 锚点：href=&quot;#top&quot;（只有锚点的话不会触发请求） href=&quot;#&quot;，空锚点，会指向页面顶部； 关于锚点定位，更多知识可以看张鑫旭文章《URL锚点HTML定位技术机制、应用与问题》 javascript伪协议：href=&quot;javascript: js代码段&quot; href=&quot;javascript: ;&quot;，这种方法是很多网站最常用的方法，也是最周全的方法，既不会做请求、不会跳转页面，也不会改变当前页面位置，还能达到想要的效果； href=&quot;javascript: void(0);&quot;，和上面这种用法类似，类似的还有一些，请看这里； 在浏览器地址栏输入 “javascript: alert(‘hello’)” 同样会执行js代码； W3C标准不推荐在href里面执行javascript语句； target 属性，指定窗口 _blank：新窗口 _self：当前，默认值 _parent：父框架 _top：最顶层,即在整个窗口中打开被链接文档 framename：指定 iframe 内联框架名称 download 属性，规定被下载的超链接目标 href 属性中就是下载内容的地址 download 属性值就是下载文件的文件名1&lt;a href=&quot;http://img.yancongwen.cn/18-4-12/34996969.jpg&quot; download=&quot;ycw.jpg&quot;&gt;下载图片&lt;/a&gt; 3、from 标签表示了文档中的一个区域，这个区域包含有交互控制元件，用来向服务器提交信息。；表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等； action 属性，URL值，绝对路径或相对路径，规定当提交表单时向何处发送表单数据 method 属性，规定用于发送 form-data 的 HTTP 方法，只能是 GET 或者 POST，其它方法无效（a 标签只能用 GET） POST (最常用)POST 请求会将数据包含在 HTTP 请求体的第四部分中 GET (一般不用)GET 请求会将数据以参数的形式附在请求URL后面 target 属性，和 a 标签中用法相同 name 属性， 其他注意点： form 标签中 input 标签必需要有 name 属性值，否则对应数据不会被提交； form 标签中必须要有一个 submit 按钮才能被提交，正是因为有 submit 按钮，才能按 回车 提交表单； 如果一个 form 标签中没有 submit 按钮 &lt;input type=&#39;submit&#39;&gt;， 而有 &lt;button&gt;&lt;/button&gt;，则 button 会默认为 submit 按钮，若写成这样 &lt;button type=&#39;button&#39;&gt;button&lt;/button&gt;” 则不会成为 submit; form 提交会刷新页面； 4、input\\button 标签 label 的两种用法，推荐第二种 12&lt;label id=\"name\"&gt;名字：&lt;/label&gt;&lt;input type=\"text\" name=\"xxx\" for=\"name\"&gt;&lt;label&gt;名字：&lt;input type=\"text\" name=\"xxx\" for=\"name\"&gt;&lt;/label&gt; button type 属性 submit， 提交表单数据，表单中未指定时，此值为默认值； reset，重置所有组件为初始值； button，没有默认行为； menu，打开一个由指定 &lt;menu\\&gt; 元素进行定义的弹出菜单； input type 属性 text，默认 button、reset、submit checkbox、radio date、datetime、datetime-local、month、time、week color file number password email range serch url tel hidden name 属性，必须有 详细细节请看 MDN 文档 input 标签的 button、reset、submit 按钮和 button 标签区别主要在于 input 标签只支持文本内容，不能再包含其他标签，但是 button 标签可以。button 比 input 更容易使用样式。 5、table 标签 过去 table 常用语页面布局，现在不推荐，专业的事情交给专业的人来做； 应当使用 CSS 定制 table 样式的样式，不推荐使用table标签中的属性设置（诸如：align、border、bgcolor、cellpadding、cellspacing 等不在推荐使用）； thead tbody tfoot不写浏览器也不会报错，而会自动补全； colgroup 用于定义数据列的样式1234567891011121314151617181920212223242526272829&lt;table border=\"1\"&gt; &lt;colgroup&gt; &lt;col width=\"100\"&gt; &lt;col bgcolor=\"red\" width=\"200\"&gt; &lt;col width=\"100\"&gt; &lt;col width=\"100\"&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;数学&lt;/th&gt;&lt;th&gt;语文&lt;/th&gt;&lt;th&gt;总分&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;小明&lt;/th&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;小白&lt;/th&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;99&lt;/td&gt;&lt;td&gt;199&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;小黑&lt;/th&gt;&lt;td&gt;99&lt;/td&gt;&lt;td&gt;99&lt;/td&gt;&lt;td&gt;198&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;平均分&lt;/th&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;99&lt;/td&gt;&lt;td&gt;199&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.yancongwen.com/tags/HTML/"}]},{"title":"计算机字符编码及JavaScript编码方式","slug":"计算机字符编码及JavaScript编码方式","date":"2017-03-30T17:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2017/03/31/计算机字符编码及JavaScript编码方式/","link":"","permalink":"http://blog.yancongwen.com/2017/03/31/计算机字符编码及JavaScript编码方式/","excerpt":"","text":"一、 计算机存储1. 位（bit）计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态.bit是计算机内存数据存储的最小单位，也称为比特，可简写为b。计算机中的CPU位数指的是CPU一次能处理的最大位数。 2. 字节（byte）八个二进制位称为一个字节，即 1byte = 8bit，1字节最多可以表示 2^8 = 256 个字符。 3. 字符计算机中使用的字母、数字、汉字、符号等。在计算机中，采用不同的字符集、不同的编码方式，一个字符占用的存储空间是不同的。 在 ASCII 编码中，一个英文字母字符存储需要1个字节; 在 GB2312 编码或 GBK 编码中，一个汉字字符存储需要2个字节； 在 UTF-8 编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节; 在 UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）; 在UTF-32编码中，世界上任何字符的存储都需要4个字节。 二、 字符编码1. ASCII American Standard Code for Information Interchange 美国字符集，主要用于显示现代英语和其他西欧语言，共128个字符； 最通用的单字节编码系统； 1字节 2. GB2312、GBK GB2312是中国国标字符集，规定了6763个中文、682个拉丁、希腊字母等， 微软在GB基础上拓展出了GBK； 2字节 3. Unicode 全世界所有的字符集合，目前，Unicode的最新版本是7.0版，一共收入了109449个符号; 包含17个平面： 1个基本面（2^16=65536个字符，范围为 U+0000 ~ U+FFFF）,16个辅助平面（U+010000 ~ U+10FFFF）； 三、编码方法Unicode只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法。 1. UTF-32 4个字节表示一个字符； 与Unicode编码一一对应，比如，字母a为0x00000061； Pro：查找效率高，时间复杂度o(1) Con：浪费空间，比相同ASCII编码大四倍 2. UTF-8 变长编码方法，1~4个字节，越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同； 节省存储空间； 由于它节省空间的特性，使用最多； 编号范围 字节 0x0000 - 0x007F 1 0x0080 - 0x07FF 2 0x0800 - 0xFFFF 3 0x010000 - 0x1FFFF 4 3. UTF-16 变长编码，2或4个字节； 基本平面的字符占用2个字节（U+0000 ~ U+FFFF），辅助平面的字符占用4个字节（U+010000 ~ U+10FFFF） 四、JavaScript采用哪种？ Unicode字符集 UCS-2编码 2个字节，且字符不全； JS被发明的时候只有UCS-2，没有UTF； 后来UTF-16取代了UCS-2，或者说UCS-2整合进了UTF-16，所以，现在只有UTF-16，没有UCS-2； 所以说JS采用的是UTF-16编码方式； 带来的问题： 由于JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理。JavaScript的字符函数都受到这一点的影响，无法返回正确结果； ES6中增强了Unicode支持，基本解决了上述问题； 参考: 阮一峰：字符编码笔记：ASCII，Unicode和UTF-8 阮一峰：Unicode与JavaScript详解","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://blog.yancongwen.com/tags/计算机基础/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-14T17:00:00.000Z","updated":"2019-03-28T06:16:34.351Z","comments":true,"path":"2017/01/15/hello-world/","link":"","permalink":"http://blog.yancongwen.com/2017/01/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}